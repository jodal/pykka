{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Pykka makes it easier to build concurrent applications.</p> <p>Pykka is a Python implementation of the actor model. The actor model introduces some simple rules to control the sharing of state and cooperation between execution units, which makes it easier to build concurrent applications.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pykka has no dependencies other than Python 3.10 or newer. It can be installed from PyPI:</p> <pre><code>$ python3 -m pip install pykka\n</code></pre> <p>Next up, check out the Getting started docs or the Reference.</p>"},{"location":"#project-resources","title":"Project resources","text":"<ul> <li>Source code</li> <li>Releases</li> <li>Issue tracker</li> <li>Contributors</li> <li>Users</li> </ul>"},{"location":"#history-and-inspiration","title":"History and inspiration","text":"<p>Pykka was originally created around 2011 as a formalization of concurrency patterns that emerged in the Mopidy music server. The original Pykka source code wasn't extracted from Mopidy, but it built and improved on the concepts from Mopidy. Mopidy was later ported to build on Pykka instead of its own concurrency abstractions.</p> <p>Much of the naming of concepts and methods in Pykka was inspired by Jonas Bon\u00e9r's conference talks around 2010 on Akka, a JVM implementation of the actor model. Pykka is not a Python port of Akka, and supports far fewer features.</p>"},{"location":"examples/","title":"Examples","text":"<p>The next pages contains a few simple examples of how to use Pykka.</p> <ul> <li>Basic actor - a simple example of a message-passing actor.</li> <li>Actor with proxy - an example of an actor with a proxy.</li> <li>Coopering actors - an example of two actors cooperating.</li> <li>Worker pool - an example using a pool of actors to split up work.</li> <li>Mopidy music server - a real-life example of using Pykka.</li> </ul> <p>All of the examples can also be found in the <code>examples/</code> directory on GitHub.</p>"},{"location":"examples/basic/","title":"Basic actor","text":"<p>This example shows:</p> <ul> <li>how to define an actor by creating a class that subclasses   <code>ThreadingActor</code> and defines the   <code>on_receive()</code> method,</li> <li>how the actor can store internal state, here done by modifying   <code>self._stored_messages</code>,</li> <li>how to start and stop and actor, using <code>start()</code> and   <code>stop()</code>, and</li> <li>how to interact with the actor from the outside, using   <code>tell()</code> and <code>ask()</code>.</li> </ul>"},{"location":"examples/basic/#example","title":"Example","text":"examples/basic.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nfrom typing import Any\n\nimport pykka\n\n# Define a unique message to request stored messages\nGetMessages = object()\n\n\nclass BasicActor(pykka.ThreadingActor):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._stored_messages: list[Any] = []\n\n    def on_receive(self, message: Any) -&gt; Any:\n        if message is GetMessages:\n            return self._stored_messages\n        self._stored_messages.append(message)\n        return None\n\n\nif __name__ == \"__main__\":\n    # Start the actor\n    actor_ref = BasicActor.start()\n\n    # Send some messages to the actor\n    actor_ref.tell({\"no\": \"Norway\", \"se\": \"Sweden\"})\n    actor_ref.tell({\"a\": 3, \"b\": 4, \"c\": 5})\n\n    # Retrieve and print stored messages\n    print(actor_ref.ask(GetMessages))\n\n    # Stop the actor\n    actor_ref.stop()\n</code></pre>"},{"location":"examples/basic/#output","title":"Output","text":"<pre><code>$ uv run examples/basic.py\n[{'no': 'Norway', 'se': 'Sweden'}, {'a': 3, 'b': 4, 'c': 5}]\n</code></pre>"},{"location":"examples/cooperation/","title":"Cooperating actors","text":"<p>This example shows how multiple actors can be set up to cooperate with each other by passing either <code>ActorRef</code> or <code>ActorProxy</code> instances to actors, either at setup time as arguments to <code>start()</code> or later through messages.</p>"},{"location":"examples/cooperation/#example","title":"Example","text":"examples/cooperation.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nimport pykka\n\n\nclass Adder(pykka.ThreadingActor):\n    def add_one(self, i: int) -&gt; int:\n        print(f\"Adder is adding 1 to {i}\")\n        return i + 1\n\n\nclass Bookkeeper(pykka.ThreadingActor):\n    def __init__(self, adder: pykka.ActorProxy[Adder]) -&gt; None:\n        super().__init__()\n        self.adder = adder\n\n    def count_to(self, target: int) -&gt; None:\n        i = 0\n        while i &lt; target:\n            i = self.adder.add_one(i).get()\n            print(f\"Bookkeeper got {i} back\")\n\n\nif __name__ == \"__main__\":\n    # Start the adder actor\n    adder = Adder.start().proxy()\n\n    # Start the bookkeeper actor, passing it the adder actor's proxy\n    bookkeeper = Bookkeeper.start(adder).proxy()\n\n    # Ask the bookkeeper to count to 5\n    bookkeeper.count_to(5).get()\n\n    # Stop all running actors using the ActorRegistry\n    pykka.ActorRegistry.stop_all()\n</code></pre>"},{"location":"examples/cooperation/#output","title":"Output","text":"<pre><code>$ uv run examples/cooperation.py\nAdder is adding 1 to 0\nBookkeeper got 1 back\nAdder is adding 1 to 1\nBookkeeper got 2 back\nAdder is adding 1 to 2\nBookkeeper got 3 back\nAdder is adding 1 to 3\nBookkeeper got 4 back\nAdder is adding 1 to 4\nBookkeeper got 5 back\n</code></pre>"},{"location":"examples/mopidy/","title":"Mopidy music server","text":"<p>Pykka was originally created around 2011 as a formalization of concurrency patterns that emerged in the Mopidy music server. The original Pykka source code wasn't extracted from Mopidy, but it built and improved on the concepts from Mopidy. Mopidy was later ported to build on Pykka instead of its own concurrency abstractions.</p> <p>Mopidy still use Pykka extensively to keep independent parts, like the MPD and HTTP servers or the Spotify and Youtube Music integrations, running independently. Every one of Mopidy's more than 100 extensions has at least one Pykka actor. By running each extension as an independent actor, errors and bugs in one extension is attempted isolated, to reduce the effect on the rest of the system.</p> <p>You can browse the Mopidy source code to find many real life examples of Pykka usage.</p>"},{"location":"examples/proxy/","title":"Actor with proxy","text":"<p>This example shows how to define an actor by creating a class that subclasses <code>ThreadingActor</code> and defines attributes and methods that can be accessed through a proxy. This makes the actor almost as easy to use as a regular class, with the only difference being that the method calls and attribute accesses are asynchronous and return futures.</p> <p>This actor does not override the <code>on_receive()</code> method, but it is entirely possible to combine the two approaches and use both regular message passing to the <code>on_receive()</code> method and proxy-based access to methods and attributes on the same actor.</p>"},{"location":"examples/proxy/#example","title":"Example","text":"examples/proxy.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nimport threading\nimport time\n\nimport pykka\n\n\ndef log(msg: str) -&gt; None:\n    thread_name = threading.current_thread().name\n    print(f\"{thread_name}: {msg}\")\n\n\nclass AnActor(pykka.ThreadingActor):\n    field = \"this is the value of AnActor.field\"\n\n    def foo(self) -&gt; None:\n        log(\"this was printed by AnActor.foo()\")\n\n    def bar(self) -&gt; str:\n        time.sleep(0.5)  # Block a bit to make it realistic\n        return \"this was returned by AnActor.bar() after a delay\"\n\n\nif __name__ == \"__main__\":\n    # Start the actor and get a proxy to it\n    proxy = AnActor.start().proxy()\n\n    # Method with side effect\n    log(\"calling AnActor.foo() ...\")\n    proxy.foo()\n\n    # Method with return value\n    log(\"calling AnActor.bar() ...\")\n    result = proxy.bar()  # Does not block, returns a future\n    log(\"printing result ... (blocking)\")\n    log(result.get())  # Blocks until ready\n\n    # Field reading\n    log(\"reading AnActor.field ...\")\n    result = proxy.field  # Does not block, returns a future\n    log(\"printing result ... (blocking)\")\n    log(result.get())  # Blocks until ready\n\n    # Field writing\n    log(\"writing AnActor.field ...\")\n    proxy.field = \"new value\"  # Assignment does not block\n    result = proxy.field  # Does not block, returns a future\n    log(\"printing new field value ... (blocking)\")\n    log(result.get())  # Blocks until ready\n\n    # Stop the actor\n    proxy.stop()\n</code></pre>"},{"location":"examples/proxy/#output","title":"Output","text":"<pre><code>$ uv run examples/proxy.py\nMainThread: calling AnActor.foo() ...\nMainThread: calling AnActor.bar() ...\nAnActor-1 (_actor_loop): this was printed by AnActor.foo()\nMainThread: printing result ... (blocking)\nMainThread: this was returned by AnActor.bar() after a delay\nMainThread: reading AnActor.field ...\nMainThread: printing result ... (blocking)\nMainThread: this is the value of AnActor.field\nMainThread: writing AnActor.field ...\nMainThread: printing new field value ... (blocking)\nMainThread: new value\n</code></pre>"},{"location":"examples/worker-pool/","title":"Worker pool","text":"<p>This example shows how to use a pool of workers to fan out work to multiple actors and then collect the result using <code>get_all()</code>.</p> <p>The example perform DNS lookups concurrently. It creates a pool of 4 workers and distributes the work of resolving a list of IP addresses among them. Each worker performs the DNS lookup and returns the result to the main thread, which collects and prints the results.</p>"},{"location":"examples/worker-pool/#example","title":"Example","text":"examples/worker_pool.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nimport pprint\nimport socket\nfrom ipaddress import IPv4Address\n\nimport pykka\n\n\nclass Resolver(pykka.ThreadingActor):\n    def resolve(self, ip: IPv4Address) -&gt; str | None:\n        try:\n            info = socket.gethostbyaddr(str(ip))\n            print(f\"Finished resolving {ip}\")\n            return info[0]\n        except Exception:\n            print(f\"Failed resolving {ip}\")\n            return None\n\n\nif __name__ == \"__main__\":\n    ip_addresses = [IPv4Address(f\"193.35.52.{i}\") for i in range(1, 20)]\n    pool_size = 4\n\n    # Start resolvers\n    pool = [Resolver.start().proxy() for _ in range(pool_size)]\n\n    # Distribute work by mapping IPs to resolvers (not blocking)\n    hosts: list[pykka.Future[str]] = []\n    for i, ip in enumerate(ip_addresses):\n        resolver = pool[i % len(pool)]\n        hosts.append(resolver.resolve(ip))\n\n    # Gather results (blocking)\n    result = list(zip(ip_addresses, pykka.get_all(hosts), strict=True))\n    pprint.pprint(result)\n\n    # Stop all actors\n    pykka.ActorRegistry.stop_all()\n</code></pre>"},{"location":"examples/worker-pool/#output","title":"Output","text":"<pre><code>$ uv run examples/worker_pool.py\nFinished resolving 193.35.52.3\nFinished resolving 193.35.52.2\nFinished resolving 193.35.52.1\nFinished resolving 193.35.52.4\nFailed resolving 193.35.52.8\nFailed resolving 193.35.52.6\nFailed resolving 193.35.52.5\nFailed resolving 193.35.52.7\nFailed resolving 193.35.52.12\nFailed resolving 193.35.52.9\nFailed resolving 193.35.52.11\nFailed resolving 193.35.52.10\nFailed resolving 193.35.52.14\nFailed resolving 193.35.52.13\nFailed resolving 193.35.52.15\nFailed resolving 193.35.52.16\nFinished resolving 193.35.52.18\nFinished resolving 193.35.52.19\nFailed resolving 193.35.52.17\n[(IPv4Address('193.35.52.1'), 'merete.samfundet.no'),\n (IPv4Address('193.35.52.2'), 'osl.samfundet.no'),\n (IPv4Address('193.35.52.3'), 'fnis.samfundet.no'),\n (IPv4Address('193.35.52.4'), 'trd.samfundet.no.52.35.193.in-addr.arpa'),\n (IPv4Address('193.35.52.5'), None),\n (IPv4Address('193.35.52.6'), None),\n (IPv4Address('193.35.52.7'), None),\n (IPv4Address('193.35.52.8'), None),\n (IPv4Address('193.35.52.9'), None),\n (IPv4Address('193.35.52.10'), None),\n (IPv4Address('193.35.52.11'), None),\n (IPv4Address('193.35.52.12'), None),\n (IPv4Address('193.35.52.13'), None),\n (IPv4Address('193.35.52.14'), None),\n (IPv4Address('193.35.52.15'), None),\n (IPv4Address('193.35.52.16'), None),\n (IPv4Address('193.35.52.17'), None),\n (IPv4Address('193.35.52.18'), 'bablefisk.samfundet.no'),\n (IPv4Address('193.35.52.19'), 'altostratus.samfundet.no')]\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>To get started with Pykka, the following sections will take you through:</p> <ul> <li>The actor model - learn about the actor model concepts and rules   that Pykka is based on.</li> <li>Message-passing actors - learn how to create, start, and stop   plain message-passing actors.</li> <li>Actor proxies - learn how to use actor proxies to interact with   actors in a convenient way.</li> </ul>"},{"location":"getting-started/actors/","title":"Message-processing actor","text":"<p>In its most basic form, a Pykka actor is a class with an <code>on_receive(message)</code> method:</p> <pre><code>import pykka\n\nclass Greeter(pykka.ThreadingActor):\n    def on_receive(self, message):\n        print(\"Hi there!\")\n</code></pre>"},{"location":"getting-started/actors/#starting-an-actor","title":"Starting an actor","text":"<p>To start an actor, you call the class' <code>start()</code> method, which starts the actor and returns an actor reference which can be used to communicate with the running actor:</p> <pre><code>actor_ref = Greeter.start()\n</code></pre> <p>If you need to pass arguments to the actor upon creation, you can pass them to the <code>start()</code> method. The actor receives the arguments using the regular <code>__init__()</code> method:</p> <pre><code>import pykka\n\nclass Greeter(pykka.ThreadingActor):\n    def __init__(self, greeting=\"Default greeting\"):\n        super().__init__()\n        self.greeting = greeting\n\n    def on_receive(self, message):\n        print(self.greeting)\n\nactor_ref = Greeter.start(greeting=\"Hi you!\")\n</code></pre> <p>It can be useful to know that the <code>__init__()</code> method is run in the execution context that starts the actor. There are also hooks for running code in the actor's own execution context when the actor starts, when it stops, and when an unhandled exception is raised. Check out the full API docs for the details.</p>"},{"location":"getting-started/actors/#stopping-an-actor","title":"Stopping an actor","text":"<p>To stop an actor, you can call <code>stop()</code> on the <code>ActorRef</code> object:</p> <pre><code>actor_ref.stop()\n</code></pre> <p>If an actor wants to stop itself, it can call <code>stop()</code> on itself. It will then exit as soon as it has finished processing the messages currently queued in its inbox.</p> <pre><code>self.stop()\n</code></pre> <p>Once an actor has been stopped, it cannot be restarted.</p>"},{"location":"getting-started/actors/#sending-messages","title":"Sending messages","text":"<p>To send a message to the actor, you can either use the <code>tell()</code> method or the <code>ask()</code> method on the <code>ActorRef</code> object:</p> <ul> <li><code>tell(message)</code> will fire off a message without waiting for an   answer. In other words, it will never block.</li> <li><code>ask(message)</code> will by default block until an answer is   returned, potentially forever. If you provide a <code>timeout</code> keyword argument,   you can specify for how long it should wait for an answer. If you want an   answer, but don't need it right away because you have other stuff you can do   first, you can use <code>ask(block=False)</code>, and it will immediately return a   \"future\" object.</li> </ul> <p>The message itself can be of any type, for example a dict or your own message class type.</p> <p>Mutable messages</p> <p>For performance reasons, Pykka does not clone the message you send before delivering it to the receiver. You are yourself responsible for either using immutable data structures or to <code>copy.deepcopy()</code> the data you're sending off to other actors.</p> <p>Summarized in code:</p> <pre><code>actor_ref.tell(\"Hi!\")\n# =&gt; Returns nothing. Will never block.\n\nanswer = actor_ref.ask(\"Hi?\")\n# =&gt; May block forever waiting for an answer\n\nanswer = actor_ref.ask(\"Hi?\", timeout=3)\n# =&gt; May wait 3s for an answer, then raises exception if no answer.\n\nfuture = actor_ref.ask(\"Hi?\", block=False)\n# =&gt; Will return a future object immediately.\nanswer = future.get()\n# =&gt; May block forever waiting for an answer\nanswer = future.get(timeout=0.1)\n# =&gt; May wait 0.1s for an answer, then raises exception if no answer.\n</code></pre>"},{"location":"getting-started/actors/#replying-to-messages","title":"Replying to messages","text":"<p>If a message is sent using <code>actor_ref.ask()</code> you can reply to the sender of the message by simply returning a value from the <code>on_receive(message)</code> method:</p> <pre><code>import pykka\n\nclass Greeter(pykka.ThreadingActor):\n    def on_receive(self, message):\n        return \"Hi there!\"\n\nactor_ref = Greeter.start()\n\nanswer = actor_ref.ask(\"Hi?\")\nprint(answer)\n# =&gt; \"Hi there!\"\n</code></pre> <p>Returning <code>None</code></p> <p><code>None</code> is a valid response, so if you return <code>None</code> explicitly, or don't return at all, a response containing <code>None</code> will be returned to the sender.</p> <p>From the point of view of the actor it doesn't matter whether the message was sent using <code>tell()</code> or <code>ask()</code>. When the sender doesn't expect a response the <code>on_receive()</code> return value will be ignored.</p> <p>The situation is similar in regard to exceptions: when <code>ask()</code> is used and you raise an exception from within the <code>on_receive()</code> method, the exception will propagate to the sender:</p> <pre><code>import pykka\n\nclass Raiser(pykka.ThreadingActor):\n    def on_receive(self, message):\n        raise Exception(\"Oops\")\n\nactor_ref = Raiser.start()\n\ntry:\n    actor_ref.ask(\"How are you?\")\nexcept Exception as e:\n    print(repr(e))\n    # =&gt; Exception(\"Oops\")\n</code></pre>"},{"location":"getting-started/model/","title":"The actor model","text":"<p>Pykka is a Python implementation of the actor model, which is a model that treats message-passing \"actors\" as the basic building blocks of concurrent computation.</p> <p>You can learn more about the actor model in general at Wikipedia.</p>"},{"location":"getting-started/model/#rules","title":"Rules","text":"<p>The actor model introduces some simple rules to control the sharing of state and cooperation between execution units, which makes it easier to build concurrent applications.</p> <ul> <li> <p>An actor is an execution unit that   executes concurrently with other actors.</p> </li> <li> <p>An actor does not share state with anybody else,   but it can have its own state.</p> </li> <li> <p>An actor can only communicate with other actors   by sending and receiving messages.   It can only send messages to actors whose address it has.</p> </li> <li> <p>When an actor receives a message it may take actions like:</p> <ul> <li>altering its own state,   e.g. so that it can react differently to a future message,</li> <li>sending messages to other actors, or</li> <li>starting new actors.</li> </ul> <p>None of the actions are required, and they may be applied in any order.</p> </li> <li> <p>An actor only processes one message at a time.   In other words, a single actor does not give you any concurrency,   and it does not need to use locks internally to protect its own state.</p> </li> </ul>"},{"location":"getting-started/proxies/","title":"Actor proxies","text":"<p>With the basic building blocks provided by actors and futures, we have everything we need to build more advanced abstractions.</p> <p>Pykka provides a single abstraction on top of the basic actor model, called \"actor proxies\". You can use Pykka without proxies, but we've found it to be a very convenient abstraction when building Mopidy.</p>"},{"location":"getting-started/proxies/#create-an-actor-and-a-proxy","title":"Create an actor and a proxy","text":"<p>Let's create an actor and start it:</p> <pre><code>import pykka\n\nclass Calculator(pykka.ThreadingActor):\n    def __init__(self):\n        super().__init__()\n        self.last_result = None\n\n    def add(self, a, b=None):\n        if b is not None:\n            self.last_result = a + b\n        else:\n            self.last_result += a\n        return self.last_result\n\n    def sub(self, a, b=None):\n        if b is not None:\n            self.last_result = a - b\n        else:\n            self.last_result -= a\n        return self.last_result\n\nactor_ref = Calculator.start()\n</code></pre> <p>You can create a proxy from any reference to a running actor:</p> <pre><code>proxy = actor_ref.proxy()\n</code></pre> <p>The proxy object will use introspection to figure out what public attributes and methods the actor has, and then mirror the full API of the actor. Any attribute or method prefixed with underscore will be ignored, which is the convention for keeping stuff private in Python.</p>"},{"location":"getting-started/proxies/#accessing-attributes-and-calling-methods","title":"Accessing attributes and calling methods","text":"<p>When we access attributes or call methods on the proxy, it will ask the actor to access the given attribute or call the given method, and return the result to us. All results are wrapped in \"future\" objects, so you must use the <code>Future.get()</code> method to get the actual data:</p> <pre><code>future = proxy.add(1, 3)\nfuture.get()\n# =&gt; 4\n\nproxy.last_result.get()\n# =&gt; 4\n</code></pre> <p>Since an actor only processes one message at the time and all messages are kept in order, you don't need to add the call to <code>get()</code> just to block processing until the actor has completed processing your last message:</p> <pre><code>proxy.sub(5)\nproxy.add(3)\nproxy.last_result.get()\n# =&gt; 2\n</code></pre> <p>Since assignment doesn't return anything, it works just like on regular objects:</p> <pre><code>proxy.last_result = 17\nproxy.last_result.get()\n# =&gt; 17\n</code></pre> <p>Under the hood, the proxy does everything by sending messages to the actor using the regular <code>ActorRef.ask()</code> method that we talked about previously. By doing so, it maintains the actor model restrictions. The only \"magic\" happening here is some basic introspection and automatic building of three different message types; one for method calls, one for attribute reads, and one for attribute writes.</p>"},{"location":"getting-started/proxies/#traversable-attributes","title":"Traversable attributes","text":"<p>Sometimes you'll want to access an actor attribute's own methods or attributes through a proxy. For this case, Pykka supports \"traversable attributes\". By marking an actor attribute as traversable, Pykka will not return the attribute when accessed, but wrap it in a new proxy which is returned instead.</p> <p>To mark an attribute as traversable, simply mark it with the <code>pykka.traversable()</code> function:</p> <pre><code>import pykka\n\nclass AnActor(pykka.ThreadingActor):\n    playback = pykka.traversable(Playback())\n\nclass Playback(object):\n    def play(self):\n        return True\n\nproxy = AnActor.start().proxy()\nplay_success = proxy.playback.play().get()\n</code></pre> <p>You can access methods and attributes nested as deep as you like, as long as all attributes on the path between the actor and the method or attribute on the end are marked as traversable.</p>"},{"location":"guides/","title":"Guides","text":"<p>This section contains guides and tutorials for using Pykka.</p> <ul> <li>Logging - learn how to configure logging in Pykka.</li> <li>Unit testing - learn how to test code that uses Pykka.</li> <li>Deadlock debugging - learn how to debug deadlocks in Pykka   applications.</li> <li>Proxy typing - learn how to add type hints for actor proxies.</li> </ul>"},{"location":"guides/deadlocks/","title":"Deadlock debugging","text":"<p>This is a complete example of how to use <code>log_thread_tracebacks()</code> as a signal handler to debug deadlocks.</p>"},{"location":"guides/deadlocks/#setting-up-a-deadlock","title":"Setting up a deadlock","text":"<p>To illustrate how to debug a deadlock, we can use the following script to set up a deadlock situation.</p> examples/deadlock.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport time\nfrom typing import Any\n\nimport pykka\nimport pykka.debug\n\nlog = logging.getLogger(__name__)\n\n\nclass ActorA(pykka.ThreadingActor):\n    def foo(self, b: pykka.ActorProxy[ActorB]) -&gt; Any:\n        log.debug(\"This is foo calling bar\")\n        return b.bar().get()\n\n\nclass ActorB(pykka.ThreadingActor):\n    def __init__(self, a: pykka.ActorProxy[ActorA]) -&gt; None:\n        super().__init__()\n        self.a = a\n\n    def bar(self) -&gt; Any:\n        log.debug(\"This is bar calling foo; BOOM!\")\n        return self.a.foo().get()\n\n\nif __name__ == \"__main__\":\n    print(\"Setting up logging to get output from signal handler...\")\n    logging.basicConfig(level=logging.DEBUG)\n\n    print(\"Registering signal handler...\")\n    signal.signal(signal.SIGUSR1, pykka.debug.log_thread_tracebacks)\n\n    print(\"Starting actors...\")\n    a = ActorA.start().proxy()\n    b = ActorB.start(a).proxy()\n\n    print(\"Now doing something stupid that will deadlock the actors...\")\n    a.foo(b)\n\n    # Yield to actors, so we get output in a readable order\n    time.sleep(0.01)\n\n    pid = os.getpid()\n    print(\"Making main thread relax; not block, not quit\")\n    print(f\"1) Use `kill -SIGUSR1 {pid:d}` to log thread tracebacks\")\n    print(f\"2) Then `kill {pid:d}` to terminate the process\")\n    while True:\n        time.sleep(1)\n</code></pre> <p>Running the script outputs the following:</p> <pre><code>\u276f uv run examples/deadlock.py\nSetting up logging to get output from signal handler...\nRegistering signal handler...\nStarting actors...\nDEBUG:pykka:Registered ActorA (urn:uuid:09d5a2ab-6d1b-4fb6-aa7f-9b3d519b2378)\nDEBUG:pykka:Starting ActorA (urn:uuid:09d5a2ab-6d1b-4fb6-aa7f-9b3d519b2378)\nDEBUG:pykka:Registered ActorB (urn:uuid:9b4c697c-fe1c-44eb-b596-bf4dd8e3c4e9)\nDEBUG:pykka:Starting ActorB (urn:uuid:9b4c697c-fe1c-44eb-b596-bf4dd8e3c4e9)\nNow doing something stupid that will deadlock the actors...\nDEBUG:__main__:This is foo calling bar\nDEBUG:__main__:This is bar calling foo; BOOM!\nMaking main thread relax; not block, not quit\n1) Use `kill -SIGUSR1 1953031` to log thread tracebacks\n2) Then `kill 1953031` to terminate the process\n</code></pre>"},{"location":"guides/deadlocks/#how-to-debug-the-deadlock","title":"How to debug the deadlock","text":"<p>The two actors are now deadlocked waiting for each other, while the main thread is idling, ready to process any signals.</p> <p>To debug the deadlock, send the <code>SIGUSR1</code> signal to the process, which has process ID 1953031 in this example:</p> <pre><code>$ kill -SIGUSR1 1953031\n$\n</code></pre> <p>This makes the main thread log the current traceback for each thread. The logging output shows that the two actors are both waiting for data from the other actor:</p> <pre><code>CRITICAL:pykka:Current state of ActorB-2 (_actor_loop) (ident: 140349254620864):\n  File \"threading.py\", line 1043, in _bootstrap\n    self._bootstrap_inner()\n  File \"threading.py\", line 1081, in _bootstrap_inner\n    self._context.run(self.run)\n  File \"threading.py\", line 1023, in run\n    self._target(*self._args, **self._kwargs)\n  File \"pykka/_actor.py\", line 229, in _actor_loop\n    self._actor_loop_running()\n  File \"pykka/_actor.py\", line 242, in _actor_loop_running\n    response = self._handle_receive(envelope.message)\n  File \"pykka/_actor.py\", line 352, in _handle_receive\n    return callee(*message.args, **message.kwargs)\n  File \"examples/deadlock.py\", line 35, in bar\n    return self.a.foo().get()\n  File \"pykka/_threading.py\", line 69, in get\n    self._condition.wait(timeout=remaining)\n  File \"threading.py\", line 369, in wait\n    waiter.acquire()\n\nCRITICAL:pykka:Current state of ActorA-1 (_actor_loop) (ident: 140349263013568):\n  File \"threading.py\", line 1043, in _bootstrap\n    self._bootstrap_inner()\n  File \"threading.py\", line 1081, in _bootstrap_inner\n    self._context.run(self.run)\n  File \"threading.py\", line 1023, in run\n    self._target(*self._args, **self._kwargs)\n  File \"pykka/_actor.py\", line 229, in _actor_loop\n    self._actor_loop_running()\n  File \"pykka/_actor.py\", line 242, in _actor_loop_running\n    response = self._handle_receive(envelope.message)\n  File \"pykka/_actor.py\", line 352, in _handle_receive\n    return callee(*message.args, **message.kwargs)\n  File \"examples/deadlock.py\", line 25, in foo\n    return b.bar().get()\n  File \"pykka/_threading.py\", line 69, in get\n    self._condition.wait(timeout=remaining)\n  File \"threading.py\", line 369, in wait\n    waiter.acquire()\n\nCRITICAL:pykka:Current state of MainThread (ident: 140349271754624):\n  File \"examples/deadlock.py\", line 59, in &lt;module&gt;\n    time.sleep(1)\n  File \"pykka/debug.py\", line 62, in log_thread_tracebacks\n    stack = \"\".join(traceback.format_stack(frame))\n</code></pre>"},{"location":"guides/logging/","title":"Logging","text":"<p>Pykka uses Python's standard <code>logging</code> module for logging debug messages and any unhandled exceptions in the actors. All log messages emitted by Pykka are issued to the logger named <code>pykka</code>, or a sub-logger of it.</p>"},{"location":"guides/logging/#log-levels","title":"Log levels","text":"<p>Pykka logs at several different log levels, so that you can filter out the parts you're not interested in:</p> <code>logging.CRITICAL</code> (highest) This level is only used by the debug helpers     in <code>pykka.debug</code>. <code>logging.ERROR</code> Exceptions raised by an actor     that are not captured into a reply future     are logged at this level. <code>logging.WARNING</code> Unhandled messages and other potential programming errors     are logged at this level. <code>logging.INFO</code> <p>Exceptions raised by an actor     that are captured into a reply future     are logged at this level.     If the future result is used elsewhere,     the exceptions is reraised there too.     If the future result isn't used,     the log message is the only trace of the exception happening.</p> <p>To catch bugs earlier, it is recommended to show log messages this level during development.</p> <code>logging.DEBUG</code> (lowest) Every time an actor is started or stopped,     and registered or unregistered in the actor registry,     a message is logged at this level. <p>In summary, you probably want to always let log messages at <code>WARNING</code> and higher through, while <code>INFO</code> should also be kept on during development.</p>"},{"location":"guides/logging/#log-handlers","title":"Log handlers","text":"<p>Out of the box, Pykka is set up with <code>logging.NullHandler</code> as the only log record handler. This is the recommended approach for logging in libraries, so that the application developer using the library will have full control over how the log messages from the library will be exposed to the application's users.</p> <p>In other words, if you want to see the log messages from Pykka anywhere, you need to add a useful handler to the root logger, or the logger named <code>pykka</code>, to get any log output from Pykka.</p> <p>The defaults provided by <code>logging.basicConfig</code> is enough to get debug log messages from Pykka:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre>"},{"location":"guides/logging/#recommended-setup","title":"Recommended setup","text":"<p>If your application is already using <code>logging</code>, and you want debug log output from your own application, but not from Pykka, you can ignore debug log messages from Pykka by increasing the threshold on the Pykka logger to <code>INFO</code> level or higher:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\nlogging.getLogger(\"pykka\").setLevel(logging.INFO)\n</code></pre> <p>Given that you've fixed all unhandled exceptions logged at the <code>INFO</code> level during development, you probably want to disable logging from Pykka at the <code>INFO</code> level in production to avoid logging exceptions that are properly handled:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\nlogging.getLogger(\"pykka\").setLevel(logging.WARNING)\n</code></pre> <p>For more details on how to use <code>logging</code>, please refer to the Python standard library documentation.</p>"},{"location":"guides/proxy-typing/","title":"Proxy typing","text":"<p>Since Pykka 4.0, Pykka has complete type hints for the public API, tested using both Mypy and Pyright.</p> <p>Due to the dynamic nature of <code>ActorProxy</code> objects, it is not possible to automatically type them correctly. The <code>pykka.typing</code> module contains helpers to manually create additional classes that correctly describe the type hints for the proxy objects. In cases where a proxy objects is used a lot, this might be worth the extra effort to increase development speed and catch bugs earlier.</p>"},{"location":"guides/proxy-typing/#example","title":"Example","text":"examples/proxy_typing.py<pre><code>from typing import cast, reveal_type\n\nfrom pykka import ActorProxy, ThreadingActor\nfrom pykka.typing import ActorMemberMixin, proxy_field, proxy_method\n\n# 1) The actor class to be proxied is defined as usual:\n\n\nclass CircleActor(ThreadingActor):\n    pi = 3.14\n\n    def area(self, radius: float) -&gt; float:\n        return self.pi * radius**2\n\n\n# 2) In addition, a proxy class is defined, which inherits from\n# ActorMemberMixin to get the correct type hints for the actor methods:\n\n\nclass CircleProxy(ActorMemberMixin, ActorProxy[CircleActor]):\n    # For each field on the proxy, a proxy_field is defined:\n    pi = proxy_field(CircleActor.pi)\n\n    # For each method on the proxy, a proxy_method is defined:\n    area = proxy_method(CircleActor.area)\n\n\n# 3) The actor is started like usual, and a proxy is created as usual, but\n# the proxy is casted to the recently defined proxy class:\nproxy = cast(\"CircleProxy\", CircleActor.start().proxy())\n\n\n# Now, the type hints for the proxy are correct:\n\nreveal_type(proxy.stop)\n# Revealed type is 'Callable[[], pykka.Future[None]]'\n\nreveal_type(proxy.pi)\n# Revealed type is 'pykka.Future[float]'\n\nreveal_type(proxy.area)\n# Revealed type is 'Callable[[float], pykka.Future[float]]'\n</code></pre>"},{"location":"guides/testing/","title":"Unit testing","text":"<p>Pykka actors can be tested using the regular Python testing tools like pytest, <code>unittest</code>, and <code>unittest.mock</code>.</p>"},{"location":"guides/testing/#general-approach","title":"General approach","text":"<p>To test actors in a setting as close to production as possible, a typical pattern is the following:</p> <ol> <li>In the test setup,     start an actor together with any actors/collaborators it depends on.     The dependencies will often be replaced by mocks to control their behavior.</li> <li>In the test,     <code>ask()</code> or     <code>tell()</code> the actor something.</li> <li>In the test,     assert on the actor's state or the return value     from the <code>ask()</code> call.</li> <li>In the test teardown,     stop the actor to properly clean up before the next test.</li> </ol>"},{"location":"guides/testing/#example","title":"Example","text":"<p>Let's look at an example actor that we want to test:</p> examples/testing.py<pre><code>from typing import Any\n\nimport pykka\n\n\nclass ProducerActor(pykka.ThreadingActor):\n    def __init__(self, consumer: pykka.ActorProxy[Any]) -&gt; None:\n        super().__init__()\n        self.consumer = consumer\n\n    def produce(self) -&gt; None:\n        new_item = {\"item\": 1, \"new\": True}\n        self.consumer.consume(new_item)\n</code></pre> <p>We can test this actor with pytest by mocking the consumer and asserting that it receives a newly produced item:</p> examples/testing_test.py<pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport pytest\nfrom testing import ProducerActor\n\nif TYPE_CHECKING:\n    from collections.abc import Generator\n    from unittest.mock import Mock\n\n    from pytest_mock import MockerFixture\n\n    from pykka import ActorProxy\n\n\n@pytest.fixture\ndef consumer_mock(mocker: MockerFixture) -&gt; Mock:\n    return mocker.Mock()\n\n\n@pytest.fixture\ndef producer(consumer_mock: Mock) -&gt; Generator[ActorProxy[ProducerActor]]:\n    # Step 1: The actor under test is wired up with\n    # its dependencies and is started.\n    proxy = ProducerActor.start(consumer_mock).proxy()\n\n    yield proxy\n\n    # Step 4: The actor is stopped to clean up before the next test.\n    proxy.stop()\n\n\ndef test_producer_actor(consumer_mock: Mock, producer: ActorProxy[ProducerActor]):\n    # Step 2: Interact with the actor.\n    # We call .get() on the last future returned by the actor to wait\n    # for the actor to process all messages before asserting anything.\n    producer.produce().get()\n\n    # Step 3: Assert that the return values or actor state is as expected.\n    consumer_mock.consume.assert_called_once_with({\"item\": 1, \"new\": True})\n</code></pre> <p>If this way of setting up and tearing down test resources is unfamiliar to you, it is strongly recommended to read up on pytest's great fixture feature.</p>"},{"location":"reference/","title":"Reference","text":"<p>This section contains reference documentation for Pykka's public API.</p> <ul> <li>Actors - the <code>Actor</code> base class and references to running actors.</li> <li>Proxies - an <code>ActorProxy</code> is a convenient abstraction on top of an <code>Actor</code>.</li> <li>Futures - a <code>Future</code> is a handle to a result that may not be available yet.</li> <li>Registry - the <code>ActorRegistry</code> lets you get references to running actors.</li> <li>Exceptions - exceptions defined by Pykka.</li> <li>Message objects - message objects used by Pykka.</li> <li>Debug helpers - helpers for debugging Pykka applications.</li> <li>Typing helpers - type annotations and helpers for Pykka.</li> <li>Runtimes - the different runtimes Pykka supports.</li> </ul>"},{"location":"reference/actors/","title":"Actors","text":""},{"location":"reference/actors/#pykka.Actor","title":"pykka.Actor","text":"<p>               Bases: <code>ABC</code></p> <p>An actor is an execution unit that executes concurrently with other actors.</p> <p>To create an actor:</p> <ol> <li> <p>subclass one of the <code>Actor</code> implementations:</p> <ul> <li><code>ThreadingActor</code></li> </ul> </li> <li> <p>implement your methods, including <code>__init__()</code>, as usual,</p> </li> <li>call <code>Actor.start()</code> on your actor class,     passing the method any arguments for your constructor.</li> </ol> <p>To stop an actor, call <code>Actor.stop()</code> or <code>ActorRef.stop()</code>.</p> Example <pre><code>import pykka\n\nclass MyActor(pykka.ThreadingActor):\n    def __init__(self, my_arg=None):\n        super().__init__()\n        ... # My optional init code with access to start() arguments\n\n    def on_start(self):\n        ... # My optional setup code in same context as on_receive()\n\n    def on_stop(self):\n        ... # My optional cleanup code in same context as on_receive()\n\n    def on_failure(self, exception_type, exception_value, traceback):\n        ... # My optional cleanup code in same context as on_receive()\n\n    def on_receive(self, message):\n        ... # My optional message handling code for a plain actor\n\n    def a_method(self, ...):\n        ... # My regular method to be used through an ActorProxy\n\nmy_actor_ref = MyActor.start(my_arg=...)\nmy_actor_ref.stop()\n</code></pre> Source code in <code>src/pykka/_actor.py</code> <pre><code>class Actor(abc.ABC):\n    \"\"\"An actor is an execution unit that executes concurrently with other actors.\n\n    To create an actor:\n\n    1.  subclass one of the [`Actor`][pykka.Actor] implementations:\n\n        - [`ThreadingActor`][pykka.ThreadingActor]\n\n    2.  implement your methods, including `__init__()`, as usual,\n    3.  call [`Actor.start()`][pykka.Actor.start] on your actor class,\n        passing the method any arguments for your constructor.\n\n    To stop an actor, call [`Actor.stop()`][pykka.Actor.stop] or\n    [`ActorRef.stop()`][pykka.ActorRef.stop].\n\n    Example:\n        ```py\n        import pykka\n\n        class MyActor(pykka.ThreadingActor):\n            def __init__(self, my_arg=None):\n                super().__init__()\n                ... # My optional init code with access to start() arguments\n\n            def on_start(self):\n                ... # My optional setup code in same context as on_receive()\n\n            def on_stop(self):\n                ... # My optional cleanup code in same context as on_receive()\n\n            def on_failure(self, exception_type, exception_value, traceback):\n                ... # My optional cleanup code in same context as on_receive()\n\n            def on_receive(self, message):\n                ... # My optional message handling code for a plain actor\n\n            def a_method(self, ...):\n                ... # My regular method to be used through an ActorProxy\n\n        my_actor_ref = MyActor.start(my_arg=...)\n        my_actor_ref.stop()\n        ```\n\n    \"\"\"\n\n    @classmethod\n    def start(\n        cls: type[A],\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; ActorRef[A]:\n        \"\"\"Start an actor.\n\n        Starting an actor also registers it in the\n        [`ActorRegistry`][pykka.ActorRegistry].\n\n        Any arguments passed to [`start()`][pykka.Actor.start] will be passed on\n        to the class constructor.\n\n        Behind the scenes, the following is happening when you call\n        [`start()`][pykka.Actor.start]:\n\n        1.  The actor is created:\n\n            1.  [`actor_urn`][pykka.Actor.actor_urn] is initialized with the\n                assigned URN.\n            2.  [`actor_inbox`][pykka.Actor.actor_inbox] is initialized with a\n                new actor inbox.\n            3.  [`actor_ref`][pykka.Actor.actor_ref] is initialized with a\n                [`pykka.ActorRef`][pykka.ActorRef] object for safely\n                communicating with the actor.\n            4.  At this point, your `__init__()` code can run.\n\n        2.  The actor is registered in [`pykka.ActorRegistry`][pykka.ActorRegistry].\n\n        3.  The actor's receive loop is started.\n\n        Returns:\n            A ref which can be used to access the actor in a safe manner.\n\n        \"\"\"\n        obj = cls(*args, **kwargs)\n        assert obj.actor_ref is not None, (\n            \"Actor.__init__() have not been called. \"\n            \"Did you forget to call super() in your override?\"\n        )\n        ActorRegistry.register(obj.actor_ref)\n        logger.debug(f\"Starting {obj}\")\n        obj._start_actor_loop()\n        return obj.actor_ref\n\n    @staticmethod\n    @abc.abstractmethod\n    def _create_actor_inbox() -&gt; ActorInbox:\n        \"\"\"Create an inbox for the actor.\n\n        Internal method for implementors of new actor types.\n        \"\"\"\n        msg = \"Use a subclass of Actor\"\n        raise NotImplementedError(msg)\n\n    @staticmethod\n    @abc.abstractmethod\n    def _create_future() -&gt; Future[Any]:\n        \"\"\"Create a future for the actor.\n\n        Internal method for implementors of new actor types.\n        \"\"\"\n        msg = \"Use a subclass of Actor\"\n        raise NotImplementedError(msg)\n\n    @abc.abstractmethod\n    def _start_actor_loop(self) -&gt; None:\n        \"\"\"Create and start the actor's event loop.\n\n        Internal method for implementors of new actor types.\n        \"\"\"\n        msg = \"Use a subclass of Actor\"\n        raise NotImplementedError(msg)\n\n    actor_urn: str\n    \"\"\"\n    The actor URN string is a universally unique identifier for the actor.\n\n    It may be used for looking up a specific actor using\n    [`ActorRegistry.get_by_urn()`][pykka.ActorRegistry.get_by_urn].\n    \"\"\"\n\n    actor_inbox: ActorInbox\n    \"\"\"\n    The actor's inbox.\n\n    Use [`ActorRef.tell()`][pykka.ActorRef.tell],\n    [`ActorRef.ask()`][pykka.ActorRef.ask], and friends to put messages in the\n    inbox.\n    \"\"\"\n\n    _actor_ref: ActorRef[Any]\n\n    @property\n    def actor_ref(self: A) -&gt; ActorRef[A]:\n        \"\"\"The actor's [`ActorRef`][pykka.ActorRef] instance.\"\"\"\n        # This property only exists to improve the typing of the ActorRef.\n        return self._actor_ref\n\n    actor_stopped: threading.Event\n    \"\"\"\n    A [`threading.Event`][threading.Event] representing whether or not the actor\n    should continue processing messages.\n\n    Use [`stop()`][pykka.Actor.stop] to change it.\n    \"\"\"\n\n    def __init__(\n        self,\n        *_args: Any,\n        **_kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Create actor.\n\n        Your are free to override `__init__()`, but you must call your\n        superclass' `__init__()` to ensure that the fields\n        [`actor_urn`][pykka.Actor.actor_urn],\n        [`actor_inbox`][pykka.Actor.actor_inbox], and\n        [`actor_ref`][pykka.Actor.actor_ref] are initialized.\n\n        You can use `super()`:\n\n            super().__init__()\n\n        Or call you superclass directly:\n\n            pykka.ThreadingActor.__init__(self)\n\n        `__init__()` is called before the actor is started and registered\n        in the [`ActorRegistry`][pykka.ActorRegistry].\n        \"\"\"\n        self.actor_urn = uuid.uuid4().urn\n        self.actor_inbox = self._create_actor_inbox()\n        self.actor_stopped = threading.Event()\n\n        self._actor_ref = ActorRef(self)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__name__} ({self.actor_urn})\"\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the actor.\n\n        It's equivalent to calling\n        [`ActorRef.stop(block=False)`][pykka.ActorRef.stop].\n        \"\"\"\n        self.actor_ref.tell(messages._ActorStop())  # noqa: SLF001\n\n    def _stop(self) -&gt; None:\n        \"\"\"Stop the actor immediately without processing the rest of the inbox.\"\"\"\n        ActorRegistry.unregister(self.actor_ref)\n        self.actor_stopped.set()\n        logger.debug(f\"Stopped {self}\")\n        try:\n            self.on_stop()\n        except Exception:  # noqa: BLE001\n            self._handle_failure(*sys.exc_info())\n\n    def _actor_loop(self) -&gt; None:\n        \"\"\"Run the actor's core loop.\n\n        This is the method that will be executed by the thread or greenlet.\n        \"\"\"\n        self._actor_loop_setup()\n        self._actor_loop_running()\n        self._actor_loop_teardown()\n\n    def _actor_loop_setup(self) -&gt; None:\n        try:\n            self.on_start()\n        except Exception:  # noqa: BLE001\n            self._handle_failure(*sys.exc_info())\n\n    def _actor_loop_running(self) -&gt; None:\n        while not self.actor_stopped.is_set():\n            envelope = self.actor_inbox.get()\n            try:\n                response = self._handle_receive(envelope.message)\n                if envelope.reply_to is not None:\n                    envelope.reply_to.set(response)\n            except Exception:  # noqa: BLE001\n                if envelope.reply_to is not None:\n                    logger.info(\n                        f\"Exception returned from {self} to caller:\",\n                        exc_info=sys.exc_info(),\n                    )\n                    envelope.reply_to.set_exception()\n                else:\n                    self._handle_failure(*sys.exc_info())\n                    try:\n                        self.on_failure(*sys.exc_info())\n                    except Exception:  # noqa: BLE001\n                        self._handle_failure(*sys.exc_info())\n            except BaseException:  # noqa: BLE001\n                exception_value = sys.exc_info()[1]\n                logger.debug(f\"{exception_value!r} in {self}. Stopping all actors.\")\n                self._stop()\n                ActorRegistry.stop_all()\n\n    def _actor_loop_teardown(self) -&gt; None:\n        while not self.actor_inbox.empty():\n            envelope = self.actor_inbox.get()\n            if envelope.reply_to is not None:\n                if isinstance(envelope.message, messages._ActorStop):  # noqa: SLF001\n                    envelope.reply_to.set(None)\n                else:\n                    envelope.reply_to.set_exception(\n                        exc_info=(\n                            ActorDeadError,\n                            ActorDeadError(\n                                f\"{self.actor_ref} stopped before handling the message\"\n                            ),\n                            None,\n                        )\n                    )\n\n    def on_start(self) -&gt; None:  # noqa: B027\n        \"\"\"Run code at the beginning of the actor's life.\n\n        Hook for doing any setup that should be done *after* the actor is\n        started, but *before* it starts processing messages.\n\n        /// note | Threading runtime\n        For [`ThreadingActor`][pykka.ThreadingActor], this method is\n        executed in the actor's own thread, while `__init__()` is executed\n        in the thread that created the actor.\n        ///\n\n        If an exception is raised by this method the stack trace will be\n        logged, and the actor will stop.\n        \"\"\"\n\n    def on_stop(self) -&gt; None:  # noqa: B027\n        \"\"\"Run code at the end of the actor's life.\n\n        Hook for doing any cleanup that should be done *after* the actor has\n        processed the last message, and *before* the actor stops.\n\n        This hook is *not* called when the actor stops because of an unhandled\n        exception. In that case, the [`on_failure()`][pykka.Actor.on_failure]\n        hook is called instead.\n\n        /// note | Threading runtime\n        For [`ThreadingActor`][pykka.ThreadingActor] this method is executed\n        in the actor's own thread, immediately before the thread exits.\n        ///\n\n        If an exception is raised by this method the stack trace will be\n        logged, and the actor will stop.\n        \"\"\"\n\n    def _handle_failure(\n        self,\n        exception_type: type[BaseException] | None,\n        exception_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Log unexpected failures, unregisters and stops the actor.\"\"\"\n        logger.error(\n            f\"Unhandled exception in {self}:\",\n            exc_info=(exception_type, exception_value, traceback),  # type: ignore[arg-type]\n        )\n        ActorRegistry.unregister(self.actor_ref)\n        self.actor_stopped.set()\n\n    def on_failure(  # noqa: B027\n        self,\n        exception_type: type[BaseException] | None,\n        exception_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Run code when an unhandled exception is raised.\n\n        Hook for doing any cleanup *after* an unhandled exception is raised,\n        and *before* the actor stops.\n\n        /// note | Threading runtime\n        For [`ThreadingActor`][pykka.ThreadingActor] this method is executed in\n        the actor's own thread, immediately before the thread exits.\n        ///\n\n        The method's arguments are the relevant information from\n        [`sys.exc_info()`][sys.exc_info].\n\n        If an exception is raised by this method the stack trace will be\n        logged, and the actor will stop.\n        \"\"\"\n\n    def _handle_receive(self, message: Any) -&gt; Any:\n        \"\"\"Handle messages sent to the actor.\"\"\"\n        if isinstance(message, messages._ActorStop):  # noqa: SLF001\n            return self._stop()\n        if isinstance(message, messages.ProxyCall):\n            callee = get_attr_directly(self, message.attr_path)\n            return callee(*message.args, **message.kwargs)\n        if isinstance(message, messages.ProxyGetAttr):\n            attr = get_attr_directly(self, message.attr_path)\n            return attr\n        if isinstance(message, messages.ProxySetAttr):\n            parent_attr = get_attr_directly(self, message.attr_path[:-1])\n            attr_name = message.attr_path[-1]\n            return setattr(parent_attr, attr_name, message.value)\n        return self.on_receive(message)\n\n    def on_receive(self, message: Any) -&gt; Any:\n        \"\"\"May be implemented for the actor to handle regular non-proxy messages.\n\n        Args:\n            message: the message to handle\n\n        Returns:\n            anything that should be sent as a reply to the sender\n\n        \"\"\"\n        logger.warning(f\"Unexpected message received by {self}: {message}\")\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.actor_inbox","title":"actor_inbox  <code>instance-attribute</code>","text":"<pre><code>actor_inbox: ActorInbox = _create_actor_inbox()\n</code></pre> <p>The actor's inbox.</p> <p>Use <code>ActorRef.tell()</code>, <code>ActorRef.ask()</code>, and friends to put messages in the inbox.</p>"},{"location":"reference/actors/#pykka.Actor.actor_ref","title":"actor_ref  <code>property</code>","text":"<pre><code>actor_ref: ActorRef[A]\n</code></pre> <p>The actor's <code>ActorRef</code> instance.</p>"},{"location":"reference/actors/#pykka.Actor.actor_stopped","title":"actor_stopped  <code>instance-attribute</code>","text":"<pre><code>actor_stopped: Event = Event()\n</code></pre> <p>A <code>threading.Event</code> representing whether or not the actor should continue processing messages.</p> <p>Use <code>stop()</code> to change it.</p>"},{"location":"reference/actors/#pykka.Actor.actor_urn","title":"actor_urn  <code>instance-attribute</code>","text":"<pre><code>actor_urn: str = urn\n</code></pre> <p>The actor URN string is a universally unique identifier for the actor.</p> <p>It may be used for looking up a specific actor using <code>ActorRegistry.get_by_urn()</code>.</p>"},{"location":"reference/actors/#pykka.Actor.__init__","title":"__init__","text":"<pre><code>__init__(*_args: Any, **_kwargs: Any) -&gt; None\n</code></pre> <p>Create actor.</p> <p>Your are free to override <code>__init__()</code>, but you must call your superclass' <code>__init__()</code> to ensure that the fields <code>actor_urn</code>, <code>actor_inbox</code>, and <code>actor_ref</code> are initialized.</p> <p>You can use <code>super()</code>:</p> <pre><code>super().__init__()\n</code></pre> <p>Or call you superclass directly:</p> <pre><code>pykka.ThreadingActor.__init__(self)\n</code></pre> <p><code>__init__()</code> is called before the actor is started and registered in the <code>ActorRegistry</code>.</p> Source code in <code>src/pykka/_actor.py</code> <pre><code>def __init__(\n    self,\n    *_args: Any,\n    **_kwargs: Any,\n) -&gt; None:\n    \"\"\"Create actor.\n\n    Your are free to override `__init__()`, but you must call your\n    superclass' `__init__()` to ensure that the fields\n    [`actor_urn`][pykka.Actor.actor_urn],\n    [`actor_inbox`][pykka.Actor.actor_inbox], and\n    [`actor_ref`][pykka.Actor.actor_ref] are initialized.\n\n    You can use `super()`:\n\n        super().__init__()\n\n    Or call you superclass directly:\n\n        pykka.ThreadingActor.__init__(self)\n\n    `__init__()` is called before the actor is started and registered\n    in the [`ActorRegistry`][pykka.ActorRegistry].\n    \"\"\"\n    self.actor_urn = uuid.uuid4().urn\n    self.actor_inbox = self._create_actor_inbox()\n    self.actor_stopped = threading.Event()\n\n    self._actor_ref = ActorRef(self)\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.on_failure","title":"on_failure","text":"<pre><code>on_failure(\n    exception_type: type[BaseException] | None,\n    exception_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Run code when an unhandled exception is raised.</p> <p>Hook for doing any cleanup after an unhandled exception is raised, and before the actor stops.</p> <p>Threading runtime</p> <p>For <code>ThreadingActor</code> this method is executed in the actor's own thread, immediately before the thread exits.</p> <p>The method's arguments are the relevant information from <code>sys.exc_info()</code>.</p> <p>If an exception is raised by this method the stack trace will be logged, and the actor will stop.</p> Source code in <code>src/pykka/_actor.py</code> <pre><code>def on_failure(  # noqa: B027\n    self,\n    exception_type: type[BaseException] | None,\n    exception_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    \"\"\"Run code when an unhandled exception is raised.\n\n    Hook for doing any cleanup *after* an unhandled exception is raised,\n    and *before* the actor stops.\n\n    /// note | Threading runtime\n    For [`ThreadingActor`][pykka.ThreadingActor] this method is executed in\n    the actor's own thread, immediately before the thread exits.\n    ///\n\n    The method's arguments are the relevant information from\n    [`sys.exc_info()`][sys.exc_info].\n\n    If an exception is raised by this method the stack trace will be\n    logged, and the actor will stop.\n    \"\"\"\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.on_receive","title":"on_receive","text":"<pre><code>on_receive(message: Any) -&gt; Any\n</code></pre> <p>May be implemented for the actor to handle regular non-proxy messages.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Any</code>)           \u2013            <p>the message to handle</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>anything that should be sent as a reply to the sender</p> </li> </ul> Source code in <code>src/pykka/_actor.py</code> <pre><code>def on_receive(self, message: Any) -&gt; Any:\n    \"\"\"May be implemented for the actor to handle regular non-proxy messages.\n\n    Args:\n        message: the message to handle\n\n    Returns:\n        anything that should be sent as a reply to the sender\n\n    \"\"\"\n    logger.warning(f\"Unexpected message received by {self}: {message}\")\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.on_start","title":"on_start","text":"<pre><code>on_start() -&gt; None\n</code></pre> <p>Run code at the beginning of the actor's life.</p> <p>Hook for doing any setup that should be done after the actor is started, but before it starts processing messages.</p> <p>Threading runtime</p> <p>For <code>ThreadingActor</code>, this method is executed in the actor's own thread, while <code>__init__()</code> is executed in the thread that created the actor.</p> <p>If an exception is raised by this method the stack trace will be logged, and the actor will stop.</p> Source code in <code>src/pykka/_actor.py</code> <pre><code>def on_start(self) -&gt; None:  # noqa: B027\n    \"\"\"Run code at the beginning of the actor's life.\n\n    Hook for doing any setup that should be done *after* the actor is\n    started, but *before* it starts processing messages.\n\n    /// note | Threading runtime\n    For [`ThreadingActor`][pykka.ThreadingActor], this method is\n    executed in the actor's own thread, while `__init__()` is executed\n    in the thread that created the actor.\n    ///\n\n    If an exception is raised by this method the stack trace will be\n    logged, and the actor will stop.\n    \"\"\"\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.on_stop","title":"on_stop","text":"<pre><code>on_stop() -&gt; None\n</code></pre> <p>Run code at the end of the actor's life.</p> <p>Hook for doing any cleanup that should be done after the actor has processed the last message, and before the actor stops.</p> <p>This hook is not called when the actor stops because of an unhandled exception. In that case, the <code>on_failure()</code> hook is called instead.</p> <p>Threading runtime</p> <p>For <code>ThreadingActor</code> this method is executed in the actor's own thread, immediately before the thread exits.</p> <p>If an exception is raised by this method the stack trace will be logged, and the actor will stop.</p> Source code in <code>src/pykka/_actor.py</code> <pre><code>def on_stop(self) -&gt; None:  # noqa: B027\n    \"\"\"Run code at the end of the actor's life.\n\n    Hook for doing any cleanup that should be done *after* the actor has\n    processed the last message, and *before* the actor stops.\n\n    This hook is *not* called when the actor stops because of an unhandled\n    exception. In that case, the [`on_failure()`][pykka.Actor.on_failure]\n    hook is called instead.\n\n    /// note | Threading runtime\n    For [`ThreadingActor`][pykka.ThreadingActor] this method is executed\n    in the actor's own thread, immediately before the thread exits.\n    ///\n\n    If an exception is raised by this method the stack trace will be\n    logged, and the actor will stop.\n    \"\"\"\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.start","title":"start  <code>classmethod</code>","text":"<pre><code>start(*args: Any, **kwargs: Any) -&gt; ActorRef[A]\n</code></pre> <p>Start an actor.</p> <p>Starting an actor also registers it in the <code>ActorRegistry</code>.</p> <p>Any arguments passed to <code>start()</code> will be passed on to the class constructor.</p> <p>Behind the scenes, the following is happening when you call <code>start()</code>:</p> <ol> <li> <p>The actor is created:</p> <ol> <li><code>actor_urn</code> is initialized with the     assigned URN.</li> <li><code>actor_inbox</code> is initialized with a     new actor inbox.</li> <li><code>actor_ref</code> is initialized with a     <code>pykka.ActorRef</code> object for safely     communicating with the actor.</li> <li>At this point, your <code>__init__()</code> code can run.</li> </ol> </li> <li> <p>The actor is registered in <code>pykka.ActorRegistry</code>.</p> </li> <li> <p>The actor's receive loop is started.</p> </li> </ol> <p>Returns:</p> <ul> <li> <code>ActorRef[A]</code>           \u2013            <p>A ref which can be used to access the actor in a safe manner.</p> </li> </ul> Source code in <code>src/pykka/_actor.py</code> <pre><code>@classmethod\ndef start(\n    cls: type[A],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ActorRef[A]:\n    \"\"\"Start an actor.\n\n    Starting an actor also registers it in the\n    [`ActorRegistry`][pykka.ActorRegistry].\n\n    Any arguments passed to [`start()`][pykka.Actor.start] will be passed on\n    to the class constructor.\n\n    Behind the scenes, the following is happening when you call\n    [`start()`][pykka.Actor.start]:\n\n    1.  The actor is created:\n\n        1.  [`actor_urn`][pykka.Actor.actor_urn] is initialized with the\n            assigned URN.\n        2.  [`actor_inbox`][pykka.Actor.actor_inbox] is initialized with a\n            new actor inbox.\n        3.  [`actor_ref`][pykka.Actor.actor_ref] is initialized with a\n            [`pykka.ActorRef`][pykka.ActorRef] object for safely\n            communicating with the actor.\n        4.  At this point, your `__init__()` code can run.\n\n    2.  The actor is registered in [`pykka.ActorRegistry`][pykka.ActorRegistry].\n\n    3.  The actor's receive loop is started.\n\n    Returns:\n        A ref which can be used to access the actor in a safe manner.\n\n    \"\"\"\n    obj = cls(*args, **kwargs)\n    assert obj.actor_ref is not None, (\n        \"Actor.__init__() have not been called. \"\n        \"Did you forget to call super() in your override?\"\n    )\n    ActorRegistry.register(obj.actor_ref)\n    logger.debug(f\"Starting {obj}\")\n    obj._start_actor_loop()\n    return obj.actor_ref\n</code></pre>"},{"location":"reference/actors/#pykka.Actor.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the actor.</p> <p>It's equivalent to calling <code>ActorRef.stop(block=False)</code>.</p> Source code in <code>src/pykka/_actor.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the actor.\n\n    It's equivalent to calling\n    [`ActorRef.stop(block=False)`][pykka.ActorRef.stop].\n    \"\"\"\n    self.actor_ref.tell(messages._ActorStop())  # noqa: SLF001\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef","title":"pykka.ActorRef","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Reference to a running actor which may safely be passed around.</p> <p><code>ActorRef</code> instances are returned by <code>Actor.start()</code> and the lookup methods in <code>ActorRegistry</code>. You should never need to create <code>ActorRef</code> instances yourself.</p> Source code in <code>src/pykka/_ref.py</code> <pre><code>class ActorRef(Generic[A]):\n    \"\"\"Reference to a running actor which may safely be passed around.\n\n    [`ActorRef`][pykka.ActorRef] instances are returned by\n    [`Actor.start()`][pykka.Actor.start] and the lookup methods in\n    [`ActorRegistry`][pykka.ActorRegistry]. You should never need to create\n    [`ActorRef`][pykka.ActorRef] instances yourself.\n    \"\"\"\n\n    #: The class of the referenced actor.\n    actor_class: type[A]\n\n    #: See :attr:`Actor.actor_urn`.\n    actor_urn: str\n\n    #: See :attr:`Actor.actor_inbox`.\n    actor_inbox: ActorInbox\n\n    #: See :attr:`Actor.actor_stopped`.\n    actor_stopped: Event\n\n    def __init__(\n        self,\n        actor: A,\n    ) -&gt; None:\n        self._actor = actor\n        self.actor_class = actor.__class__\n        self.actor_urn = actor.actor_urn\n        self.actor_inbox = actor.actor_inbox\n        self.actor_stopped = actor.actor_stopped\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;ActorRef for {self}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.actor_class.__name__} ({self.actor_urn})\"\n\n    def is_alive(self) -&gt; bool:\n        \"\"\"Check if actor is alive.\n\n        This is based on the actor's stopped flag. The actor is not guaranteed\n        to be alive and responding even though\n        [`is_alive()`][pykka.ActorRef.is_alive] returns `True`.\n\n        Returns:\n            `True` if actor is alive, `False` otherwise.\n\n        \"\"\"\n        return not self.actor_stopped.is_set()\n\n    def tell(\n        self,\n        message: Any,\n    ) -&gt; None:\n        \"\"\"Send message to actor without waiting for any response.\n\n        Will generally not block, but if the underlying queue is full it will\n        block until a free slot is available.\n\n        Args:\n            message: message to send\n\n        Raises:\n            ActorDeadError: if actor is not available\n\n        \"\"\"\n        if not self.is_alive():\n            msg = f\"{self} not found\"\n            raise ActorDeadError(msg)\n        self.actor_inbox.put(Envelope(message))\n\n    @overload\n    def ask(\n        self,\n        message: Any,\n        *,\n        block: Literal[False],\n        timeout: float | None = None,\n    ) -&gt; Future[Any]: ...\n\n    @overload\n    def ask(\n        self,\n        message: Any,\n        *,\n        block: Literal[True],\n        timeout: float | None = None,\n    ) -&gt; Any: ...\n\n    @overload\n    def ask(\n        self,\n        message: Any,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; Any | Future[Any]: ...\n\n    def ask(\n        self,\n        message: Any,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; Any | Future[Any]:\n        \"\"\"Send message to actor and wait for the reply.\n\n        The message can be of any type.\n        If `block` is `False`, it will immediately return a\n        [`Future`][pykka.Future] instead of blocking.\n\n        If `block` is `True`, and `timeout` is `None`, as default, the method\n        will block until it gets a reply, potentially forever. If `timeout` is\n        an integer or float, the method will wait for a reply for `timeout`\n        seconds, and then raise [`pykka.Timeout`][pykka.Timeout].\n\n        Args:\n            message: message to send\n            block: whether to block while waiting for a reply\n            timeout: seconds to wait before timeout if blocking\n\n        Raises:\n            Timeout: if timeout is reached if blocking\n            Exception: any exception returned by the receiving actor if blocking\n\n        Returns:\n            a future if not blocking, or a response if blocking\n\n        \"\"\"\n        future = self.actor_class._create_future()  # noqa: SLF001\n\n        try:\n            if not self.is_alive():\n                msg = f\"{self} not found\"\n                raise ActorDeadError(msg)  # noqa: TRY301\n        except ActorDeadError:\n            future.set_exception()\n        else:\n            self.actor_inbox.put(Envelope(message, reply_to=future))\n\n        if block:\n            return future.get(timeout=timeout)\n\n        return future\n\n    @overload\n    def stop(\n        self,\n        *,\n        block: Literal[True],\n        timeout: float | None = None,\n    ) -&gt; bool: ...\n\n    @overload\n    def stop(\n        self,\n        *,\n        block: Literal[False],\n        timeout: float | None = None,\n    ) -&gt; Future[bool]: ...\n\n    @overload\n    def stop(\n        self,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; bool | Future[bool]: ...\n\n    def stop(\n        self,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; bool | Future[bool]:\n        \"\"\"Send a message to the actor, asking it to stop.\n\n        Returns :class:`True` if actor is stopped or was being stopped at the\n        time of the call. :class:`False` if actor was already dead. If\n        ``block`` is :class:`False`, it returns a future wrapping the result.\n\n        Messages sent to the actor before the actor is asked to stop will\n        be processed normally before it stops.\n\n        Messages sent to the actor after the actor is asked to stop will\n        be replied to with :exc:`pykka.ActorDeadError` after it stops.\n\n        The actor may not be restarted.\n\n        ``block`` and ``timeout`` works as for :meth:`ask`.\n\n        Returns:\n            a future if not blocking, or a boolean result if blocking\n\n        \"\"\"\n        ask_future = self.ask(_ActorStop(), block=False)\n\n        def _stop_result_converter(timeout: float | None) -&gt; bool:\n            try:\n                ask_future.get(timeout=timeout)\n            except ActorDeadError:\n                return False\n            else:\n                return True\n\n        converted_future = ask_future.__class__()\n        converted_future.set_get_hook(_stop_result_converter)\n        converted_future = cast(\"Future[bool]\", converted_future)\n\n        if block:\n            return converted_future.get(timeout=timeout)\n\n        return converted_future\n\n    def proxy(self: ActorRef[A]) -&gt; ActorProxy[A]:\n        \"\"\"Wrap the [`ActorRef`][pykka.ActorRef] in an [`ActorProxy`][pykka.ActorProxy].\n\n        Using this method like this:\n\n            proxy = AnActor.start().proxy()\n\n        is analogous to:\n\n            proxy = ActorProxy(AnActor.start())\n\n        Raises:\n            ActorDeadError: if actor is not available\n\n        Returns:\n            a proxy object wrapping the actor reference.\n\n        \"\"\"\n        return ActorProxy(actor_ref=self)\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef.ask","title":"ask","text":"<pre><code>ask(\n    message: Any,\n    *,\n    block: Literal[False],\n    timeout: float | None = None,\n) -&gt; Future[Any]\n</code></pre><pre><code>ask(\n    message: Any,\n    *,\n    block: Literal[True],\n    timeout: float | None = None,\n) -&gt; Any\n</code></pre><pre><code>ask(\n    message: Any,\n    *,\n    block: bool = True,\n    timeout: float | None = None,\n) -&gt; Any | Future[Any]\n</code></pre> <pre><code>ask(\n    message: Any,\n    *,\n    block: bool = True,\n    timeout: float | None = None,\n) -&gt; Any | Future[Any]\n</code></pre> <p>Send message to actor and wait for the reply.</p> <p>The message can be of any type. If <code>block</code> is <code>False</code>, it will immediately return a <code>Future</code> instead of blocking.</p> <p>If <code>block</code> is <code>True</code>, and <code>timeout</code> is <code>None</code>, as default, the method will block until it gets a reply, potentially forever. If <code>timeout</code> is an integer or float, the method will wait for a reply for <code>timeout</code> seconds, and then raise <code>pykka.Timeout</code>.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Any</code>)           \u2013            <p>message to send</p> </li> <li> <code>block</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to block while waiting for a reply</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>seconds to wait before timeout if blocking</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Timeout</code>             \u2013            <p>if timeout is reached if blocking</p> </li> <li> <code>Exception</code>             \u2013            <p>any exception returned by the receiving actor if blocking</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any | Future[Any]</code>           \u2013            <p>a future if not blocking, or a response if blocking</p> </li> </ul> Source code in <code>src/pykka/_ref.py</code> <pre><code>def ask(\n    self,\n    message: Any,\n    *,\n    block: bool = True,\n    timeout: float | None = None,\n) -&gt; Any | Future[Any]:\n    \"\"\"Send message to actor and wait for the reply.\n\n    The message can be of any type.\n    If `block` is `False`, it will immediately return a\n    [`Future`][pykka.Future] instead of blocking.\n\n    If `block` is `True`, and `timeout` is `None`, as default, the method\n    will block until it gets a reply, potentially forever. If `timeout` is\n    an integer or float, the method will wait for a reply for `timeout`\n    seconds, and then raise [`pykka.Timeout`][pykka.Timeout].\n\n    Args:\n        message: message to send\n        block: whether to block while waiting for a reply\n        timeout: seconds to wait before timeout if blocking\n\n    Raises:\n        Timeout: if timeout is reached if blocking\n        Exception: any exception returned by the receiving actor if blocking\n\n    Returns:\n        a future if not blocking, or a response if blocking\n\n    \"\"\"\n    future = self.actor_class._create_future()  # noqa: SLF001\n\n    try:\n        if not self.is_alive():\n            msg = f\"{self} not found\"\n            raise ActorDeadError(msg)  # noqa: TRY301\n    except ActorDeadError:\n        future.set_exception()\n    else:\n        self.actor_inbox.put(Envelope(message, reply_to=future))\n\n    if block:\n        return future.get(timeout=timeout)\n\n    return future\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef.is_alive","title":"is_alive","text":"<pre><code>is_alive() -&gt; bool\n</code></pre> <p>Check if actor is alive.</p> <p>This is based on the actor's stopped flag. The actor is not guaranteed to be alive and responding even though <code>is_alive()</code> returns <code>True</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if actor is alive, <code>False</code> otherwise.</p> </li> </ul> Source code in <code>src/pykka/_ref.py</code> <pre><code>def is_alive(self) -&gt; bool:\n    \"\"\"Check if actor is alive.\n\n    This is based on the actor's stopped flag. The actor is not guaranteed\n    to be alive and responding even though\n    [`is_alive()`][pykka.ActorRef.is_alive] returns `True`.\n\n    Returns:\n        `True` if actor is alive, `False` otherwise.\n\n    \"\"\"\n    return not self.actor_stopped.is_set()\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef.proxy","title":"proxy","text":"<pre><code>proxy() -&gt; ActorProxy[A]\n</code></pre> <p>Wrap the <code>ActorRef</code> in an <code>ActorProxy</code>.</p> <p>Using this method like this:</p> <pre><code>proxy = AnActor.start().proxy()\n</code></pre> <p>is analogous to:</p> <pre><code>proxy = ActorProxy(AnActor.start())\n</code></pre> <p>Raises:</p> <ul> <li> <code>ActorDeadError</code>             \u2013            <p>if actor is not available</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ActorProxy[A]</code>           \u2013            <p>a proxy object wrapping the actor reference.</p> </li> </ul> Source code in <code>src/pykka/_ref.py</code> <pre><code>def proxy(self: ActorRef[A]) -&gt; ActorProxy[A]:\n    \"\"\"Wrap the [`ActorRef`][pykka.ActorRef] in an [`ActorProxy`][pykka.ActorProxy].\n\n    Using this method like this:\n\n        proxy = AnActor.start().proxy()\n\n    is analogous to:\n\n        proxy = ActorProxy(AnActor.start())\n\n    Raises:\n        ActorDeadError: if actor is not available\n\n    Returns:\n        a proxy object wrapping the actor reference.\n\n    \"\"\"\n    return ActorProxy(actor_ref=self)\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef.stop","title":"stop","text":"<pre><code>stop(\n    *, block: Literal[True], timeout: float | None = None\n) -&gt; bool\n</code></pre><pre><code>stop(\n    *, block: Literal[False], timeout: float | None = None\n) -&gt; Future[bool]\n</code></pre><pre><code>stop(\n    *, block: bool = True, timeout: float | None = None\n) -&gt; bool | Future[bool]\n</code></pre> <pre><code>stop(\n    *, block: bool = True, timeout: float | None = None\n) -&gt; bool | Future[bool]\n</code></pre> <p>Send a message to the actor, asking it to stop.</p> <p>Returns :class:<code>True</code> if actor is stopped or was being stopped at the time of the call. :class:<code>False</code> if actor was already dead. If <code>block</code> is :class:<code>False</code>, it returns a future wrapping the result.</p> <p>Messages sent to the actor before the actor is asked to stop will be processed normally before it stops.</p> <p>Messages sent to the actor after the actor is asked to stop will be replied to with :exc:<code>pykka.ActorDeadError</code> after it stops.</p> <p>The actor may not be restarted.</p> <p><code>block</code> and <code>timeout</code> works as for :meth:<code>ask</code>.</p> <p>Returns:</p> <ul> <li> <code>bool | Future[bool]</code>           \u2013            <p>a future if not blocking, or a boolean result if blocking</p> </li> </ul> Source code in <code>src/pykka/_ref.py</code> <pre><code>def stop(\n    self,\n    *,\n    block: bool = True,\n    timeout: float | None = None,\n) -&gt; bool | Future[bool]:\n    \"\"\"Send a message to the actor, asking it to stop.\n\n    Returns :class:`True` if actor is stopped or was being stopped at the\n    time of the call. :class:`False` if actor was already dead. If\n    ``block`` is :class:`False`, it returns a future wrapping the result.\n\n    Messages sent to the actor before the actor is asked to stop will\n    be processed normally before it stops.\n\n    Messages sent to the actor after the actor is asked to stop will\n    be replied to with :exc:`pykka.ActorDeadError` after it stops.\n\n    The actor may not be restarted.\n\n    ``block`` and ``timeout`` works as for :meth:`ask`.\n\n    Returns:\n        a future if not blocking, or a boolean result if blocking\n\n    \"\"\"\n    ask_future = self.ask(_ActorStop(), block=False)\n\n    def _stop_result_converter(timeout: float | None) -&gt; bool:\n        try:\n            ask_future.get(timeout=timeout)\n        except ActorDeadError:\n            return False\n        else:\n            return True\n\n    converted_future = ask_future.__class__()\n    converted_future.set_get_hook(_stop_result_converter)\n    converted_future = cast(\"Future[bool]\", converted_future)\n\n    if block:\n        return converted_future.get(timeout=timeout)\n\n    return converted_future\n</code></pre>"},{"location":"reference/actors/#pykka.ActorRef.tell","title":"tell","text":"<pre><code>tell(message: Any) -&gt; None\n</code></pre> <p>Send message to actor without waiting for any response.</p> <p>Will generally not block, but if the underlying queue is full it will block until a free slot is available.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Any</code>)           \u2013            <p>message to send</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ActorDeadError</code>             \u2013            <p>if actor is not available</p> </li> </ul> Source code in <code>src/pykka/_ref.py</code> <pre><code>def tell(\n    self,\n    message: Any,\n) -&gt; None:\n    \"\"\"Send message to actor without waiting for any response.\n\n    Will generally not block, but if the underlying queue is full it will\n    block until a free slot is available.\n\n    Args:\n        message: message to send\n\n    Raises:\n        ActorDeadError: if actor is not available\n\n    \"\"\"\n    if not self.is_alive():\n        msg = f\"{self} not found\"\n        raise ActorDeadError(msg)\n    self.actor_inbox.put(Envelope(message))\n</code></pre>"},{"location":"reference/debug/","title":"Debug helpers","text":""},{"location":"reference/debug/#pykka.debug","title":"pykka.debug","text":"<p>Debug helpers.</p>"},{"location":"reference/debug/#pykka.debug.log_thread_tracebacks","title":"log_thread_tracebacks","text":"<pre><code>log_thread_tracebacks(*_args: Any, **_kwargs: Any) -&gt; None\n</code></pre> <p>Log a traceback for each running thread at <code>CRITICAL</code> level.</p> <p>This can be a convenient tool for debugging deadlocks.</p> <p>The function accepts any arguments so that it can easily be used as e.g. a signal handler, but it does not use the arguments for anything.</p>"},{"location":"reference/debug/#pykka.debug.log_thread_tracebacks--setup","title":"Setup","text":"<p>To use this function as a signal handler, setup logging with a <code>CRITICAL</code> threshold or lower and make your main thread register this with the <code>signal</code> module:</p> <pre><code>import logging\nimport signal\n\nimport pykka.debug\n\nlogging.basicConfig(level=logging.DEBUG)\nsignal.signal(signal.SIGUSR1, pykka.debug.log_thread_tracebacks)\n</code></pre> <p>Then, if your application deadlocks, send the <code>SIGUSR1</code> signal to the process:</p> <pre><code>kill -SIGUSR1 &lt;pid of your process&gt;\n</code></pre>"},{"location":"reference/debug/#pykka.debug.log_thread_tracebacks--limitations","title":"Limitations","text":"<ul> <li> <p>The function must be registered as a signal handler by your main thread.   If not, <code>signal.signal()</code> will raise a   <code>ValueError</code>.</p> </li> <li> <p>All signals in Python are handled by the main thread. Thus, the signal   will only be handled, and the tracebacks logged, if your main thread is   available to do some work. Making your main thread idle using   <code>time.sleep()</code> is OK. The signal will awaken your main thread.   Blocking your main thread on e.g. <code>queue.Queue.get()</code>   or <code>pykka.Future.get()</code> will break signal handling,   and thus you won't be able to signal your process to print the thread   tracebacks.</p> </li> </ul> <p>The morale is: setup signals using your main thread, start your actors, then let your main thread relax for the rest of your application's life cycle.</p> <p>Version added: Pykka 1.1</p> Source code in <code>src/pykka/debug.py</code> <pre><code>def log_thread_tracebacks(*_args: Any, **_kwargs: Any) -&gt; None:\n    \"\"\"Log a traceback for each running thread at [`CRITICAL`][logging.CRITICAL] level.\n\n    This can be a convenient tool for debugging deadlocks.\n\n    The function accepts any arguments so that it can easily be used as e.g. a\n    signal handler, but it does not use the arguments for anything.\n\n    # Setup\n\n    To use this function as a signal handler, setup logging with a\n    [`CRITICAL`][logging.CRITICAL] threshold or lower and make your main thread\n    register this with the [`signal`][signal] module:\n\n        import logging\n        import signal\n\n        import pykka.debug\n\n        logging.basicConfig(level=logging.DEBUG)\n        signal.signal(signal.SIGUSR1, pykka.debug.log_thread_tracebacks)\n\n    Then, if your application deadlocks, send the `SIGUSR1` signal to the\n    process:\n\n        kill -SIGUSR1 &lt;pid of your process&gt;\n\n    # Limitations\n\n    - The function *must* be registered as a signal handler by your main thread.\n      If not, [`signal.signal()`][signal.signal] will raise a\n      [`ValueError`][ValueError].\n\n    - All signals in Python are handled by the main thread. Thus, the signal\n      will only be handled, and the tracebacks logged, if your main thread is\n      available to do some work. Making your main thread idle using\n      [`time.sleep()`][time.sleep] is OK. The signal will awaken your main thread.\n      Blocking your main thread on e.g. [`queue.Queue.get()`][queue.Queue.get]\n      or [`pykka.Future.get()`][pykka.Future.get] will break signal handling,\n      and thus you won't be able to signal your process to print the thread\n      tracebacks.\n\n    The morale is: setup signals using your main thread, start your actors,\n    then let your main thread relax for the rest of your application's life\n    cycle.\n\n    /// note | Version added: Pykka 1.1\n    ///\n\n    \"\"\"\n    thread_names = {t.ident: t.name for t in threading.enumerate()}\n\n    for ident, frame in sys._current_frames().items():  # noqa: SLF001\n        name = thread_names.get(ident, \"?\")\n        stack = \"\".join(traceback.format_stack(frame))\n        logger.critical(f\"Current state of {name} (ident: {ident}):\\n{stack}\")\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#pykka.ActorDeadError","title":"pykka.ActorDeadError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when trying to use a dead or unavailable actor.</p> Source code in <code>src/pykka/_exceptions.py</code> <pre><code>class ActorDeadError(Exception):\n    \"\"\"Exception raised when trying to use a dead or unavailable actor.\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#pykka.Timeout","title":"pykka.Timeout","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised at future timeout.</p> Source code in <code>src/pykka/_exceptions.py</code> <pre><code>class Timeout(Exception):  # noqa: N818\n    \"\"\"Exception raised at future timeout.\"\"\"\n</code></pre>"},{"location":"reference/futures/","title":"Futures","text":""},{"location":"reference/futures/#pykka.Future","title":"pykka.Future","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A handle to a value which is available now or in the future.</p> <p>Typically returned by calls to actor methods or accesses to actor fields.</p> <p>To get hold of the encapsulated value, call <code>Future.get()</code> or <code>await</code> the future.</p> Source code in <code>src/pykka/_future.py</code> <pre><code>class Future(Generic[T]):\n    \"\"\"A handle to a value which is available now or in the future.\n\n    Typically returned by calls to actor methods or accesses to actor fields.\n\n    To get hold of the encapsulated value, call\n    [`Future.get()`][pykka.Future.get] or `await` the future.\n    \"\"\"\n\n    _get_hook: GetHookFunc[T] | None\n    _get_hook_result: T | _Unset\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._get_hook = None\n        self._get_hook_result = _Unset()\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;pykka.Future&gt;\"\n\n    def get(\n        self,\n        *,\n        timeout: float | None = None,\n    ) -&gt; T:\n        \"\"\"Get the value encapsulated by the future.\n\n        If the encapsulated value is an exception, it is raised instead of\n        returned.\n\n        If `timeout` is `None`, as default, the method will block until it gets\n        a reply, potentially forever. If `timeout` is an integer or float, the\n        method will wait for a reply for `timeout` seconds, and then raise\n        [`Timeout`][pykka.Timeout].\n\n        The encapsulated value can be retrieved multiple times. The future will\n        only block the first time the value is accessed.\n\n        Args:\n            timeout: seconds to wait before timeout\n\n        Raises:\n            pykka.Timeout: if timeout is reached\n            Exception: encapsulated value if it is an exception\n\n        Returns:\n            encapsulated value if it is not an exception\n\n        \"\"\"\n        if self._get_hook is not None:\n            if isinstance(self._get_hook_result, _Unset):\n                self._get_hook_result = self._get_hook(timeout)\n            return self._get_hook_result\n        raise NotImplementedError\n\n    def set(\n        self,\n        value: T | None = None,\n    ) -&gt; None:\n        \"\"\"Set the encapsulated value.\n\n        Args:\n            value: the encapsulated value or nothing\n\n        Raises:\n            Exception: an exception if `set()` is called multiple times\n\n        /// note | Version changed: Pykka 4.3\n        Calling `set()` on a future that already has a get hook set now\n        raises an exception.\n        ///\n\n        \"\"\"\n        raise NotImplementedError\n\n    def set_exception(\n        self,\n        exc_info: OptExcInfo | None = None,\n    ) -&gt; None:\n        \"\"\"Set an exception as the encapsulated value.\n\n        You can pass an `exc_info` three-tuple, as returned by\n        [`sys.exc_info()`][sys.exc_info]. If you don't pass `exc_info`,\n        [`sys.exc_info()`][sys.exc_info] will be called and the value returned\n        by it used.\n\n        In other words, if you're calling `set_exception()`, without any\n        arguments, from an except block, the exception you're currently handling\n        will automatically be set on the future.\n\n        Args:\n            exc_info: the encapsulated exception\n\n        /// note | Version changed: Pykka 4.3\n        Calling `set_exception()` on a future that already has a get hook\n        set now raises an exception.\n        ///\n\n        \"\"\"\n        raise NotImplementedError\n\n    def set_get_hook(\n        self,\n        func: GetHookFunc[T],\n    ) -&gt; None:\n        \"\"\"Set a function to be executed when [`get()`][pykka.Future.get] is called.\n\n        The function will be called when [`get()`][pykka.Future.get] is called, with the\n        `timeout` value as the only argument. The function's return value will\n        be returned from [`get()`][pykka.Future.get].\n\n        Args:\n            func: callable accepting a timeout value, to produce return value of\n                `get()`\n\n        /// note | Version added: Pykka 1.2\n        ///\n\n        /// note | Version changed: Pykka 4.3\n        Calling `set_get_hook()` on a future that already has a result set\n        now raises an exception.\n        ///\n\n        \"\"\"\n        self._get_hook = func\n\n    def filter(\n        self: Future[Iterable[J]],\n        func: Callable[[J], bool],\n    ) -&gt; Future[Iterable[J]]:\n        \"\"\"Return a new future with only the items passing the predicate function.\n\n        If the future's value is an iterable, `filter()` will return a new\n        future whose value is another iterable with only the items from the\n        first iterable for which `func(item)` is true. If the future's value\n        isn't an iterable, a [`TypeError`][TypeError] will be raised when\n        [`get()`][pykka.Future.get] is called.\n\n        Example:\n            ```pycon\n            &gt;&gt;&gt; import pykka\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.filter(lambda x: x &gt; 10)\n            &gt;&gt;&gt; g\n            &lt;pykka.future.ThreadingFuture at ...&gt;\n            &gt;&gt;&gt; f.set(range(5, 15))\n            &gt;&gt;&gt; f.get()\n            [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n            &gt;&gt;&gt; g.get()\n            [11, 12, 13, 14]\n            ```\n\n        /// note | Version added: Pykka 1.2\n        ///\n\n        \"\"\"\n        future = self.__class__()\n        future.set_get_hook(\n            lambda timeout: list(filter(func, self.get(timeout=timeout)))\n        )\n        return future\n\n    def join(\n        self: Future[Any],\n        *futures: Future[Any],\n    ) -&gt; Future[Iterable[Any]]:\n        \"\"\"Return a new future with a list of the result of multiple futures.\n\n        One or more futures can be passed as arguments to `join()`. The new\n        future returns a list with the results from all the joined futures.\n\n        Example:\n            ```pycon\n            &gt;&gt;&gt; import pykka\n            &gt;&gt;&gt; f1 = pykka.ThreadingFuture()\n            &gt;&gt;&gt; f2 = pykka.ThreadingFuture()\n            &gt;&gt;&gt; f3 = pykka.ThreadingFuture()\n            &gt;&gt;&gt; f = f1.join(f2, f3)\n            &gt;&gt;&gt; f1.set('abc')\n            &gt;&gt;&gt; f2.set(123)\n            &gt;&gt;&gt; f3.set(False)\n            &gt;&gt;&gt; f.get()\n            ['abc', 123, False]\n            ```\n\n        /// note | Version added: Pykka 1.2\n        ///\n\n        \"\"\"\n        future = cast(\"Future[Iterable[Any]]\", self.__class__())\n        future.set_get_hook(\n            lambda timeout: [f.get(timeout=timeout) for f in [self, *futures]]\n        )\n        return future\n\n    def map(\n        self,\n        func: Callable[[T], M],\n    ) -&gt; Future[M]:\n        \"\"\"Pass the result of the future through a function.\n\n        Example:\n            ```pycon\n            &gt;&gt;&gt; import pykka\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.map(lambda x: x + 10)\n            &gt;&gt;&gt; f.set(30)\n            &gt;&gt;&gt; g.get()\n            40\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.map(lambda x: x['foo'])\n            &gt;&gt;&gt; f.set({'foo': 'bar'}})\n            &gt;&gt;&gt; g.get()\n            'bar'\n            ```\n\n        /// note | Version added: Pykka 1.2\n        ///\n\n        /// note | Version changed: Pykka 2.0\n        Previously, if the future's result was an iterable (except a\n        string), the function was applied to each item in the iterable.\n        This behavior was unpredictable and made regular use cases like\n        extracting a single field from a dict difficult, thus the\n        behavior has been simplified. Since Pykka 2.0, the entire result\n        value is passed to the function.\n        ///\n\n        \"\"\"\n        future = cast(\"Future[M]\", self.__class__())\n        future.set_get_hook(lambda timeout: func(self.get(timeout=timeout)))\n        return future\n\n    def reduce(\n        self: Future[Iterable[J]],\n        func: Callable[[R, J], R],\n        *args: R,\n    ) -&gt; Future[R]:\n        \"\"\"Reduce a future's iterable result to a single value.\n\n        The function of two arguments is applied cumulatively to the items of\n        the iterable, from left to right. The result of the first function call\n        is used as the first argument to the second function call, and so on,\n        until the end of the iterable. If the future's value isn't an iterable,\n        a [`TypeError`][TypeError] is raised.\n\n        `reduce()` accepts an optional second argument, which will be used as an\n        initial value in the first function call. If the iterable is empty, the\n        initial value is returned.\n\n        Example:\n            ```pycon\n            &gt;&gt;&gt; import pykka\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n            &gt;&gt;&gt; f.set(['a', 'b', 'c'])\n            &gt;&gt;&gt; g.get()\n            'abc'\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n            &gt;&gt;&gt; f.set([1, 2, 3])\n            &gt;&gt;&gt; (1 + 2) + 3\n            6\n            &gt;&gt;&gt; g.get()\n            6\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n            &gt;&gt;&gt; f.set([1, 2, 3])\n            &gt;&gt;&gt; ((5 + 1) + 2) + 3\n            11\n            &gt;&gt;&gt; g.get()\n            11\n\n            &gt;&gt;&gt; f = pykka.ThreadingFuture()\n            &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n            &gt;&gt;&gt; f.set([])\n            &gt;&gt;&gt; g.get()\n            5\n            ```\n\n        /// note | Version added: Pykka 1.2\n        ///\n\n        \"\"\"\n        future = cast(\"Future[R]\", self.__class__())\n        future.set_get_hook(\n            lambda timeout: functools.reduce(func, self.get(timeout=timeout), *args)\n        )\n        return future\n\n    def __await__(self) -&gt; Generator[None, None, T]:\n        yield\n        value = self.get()\n        return value\n\n    __iter__ = __await__\n</code></pre>"},{"location":"reference/futures/#pykka.Future.filter","title":"filter","text":"<pre><code>filter(func: Callable[[J], bool]) -&gt; Future[Iterable[J]]\n</code></pre> <p>Return a new future with only the items passing the predicate function.</p> <p>If the future's value is an iterable, <code>filter()</code> will return a new future whose value is another iterable with only the items from the first iterable for which <code>func(item)</code> is true. If the future's value isn't an iterable, a <code>TypeError</code> will be raised when <code>get()</code> is called.</p> Example <pre><code>&gt;&gt;&gt; import pykka\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.filter(lambda x: x &gt; 10)\n&gt;&gt;&gt; g\n&lt;pykka.future.ThreadingFuture at ...&gt;\n&gt;&gt;&gt; f.set(range(5, 15))\n&gt;&gt;&gt; f.get()\n[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n&gt;&gt;&gt; g.get()\n[11, 12, 13, 14]\n</code></pre> <p>Version added: Pykka 1.2</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def filter(\n    self: Future[Iterable[J]],\n    func: Callable[[J], bool],\n) -&gt; Future[Iterable[J]]:\n    \"\"\"Return a new future with only the items passing the predicate function.\n\n    If the future's value is an iterable, `filter()` will return a new\n    future whose value is another iterable with only the items from the\n    first iterable for which `func(item)` is true. If the future's value\n    isn't an iterable, a [`TypeError`][TypeError] will be raised when\n    [`get()`][pykka.Future.get] is called.\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pykka\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.filter(lambda x: x &gt; 10)\n        &gt;&gt;&gt; g\n        &lt;pykka.future.ThreadingFuture at ...&gt;\n        &gt;&gt;&gt; f.set(range(5, 15))\n        &gt;&gt;&gt; f.get()\n        [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n        &gt;&gt;&gt; g.get()\n        [11, 12, 13, 14]\n        ```\n\n    /// note | Version added: Pykka 1.2\n    ///\n\n    \"\"\"\n    future = self.__class__()\n    future.set_get_hook(\n        lambda timeout: list(filter(func, self.get(timeout=timeout)))\n    )\n    return future\n</code></pre>"},{"location":"reference/futures/#pykka.Future.get","title":"get","text":"<pre><code>get(*, timeout: float | None = None) -&gt; T\n</code></pre> <p>Get the value encapsulated by the future.</p> <p>If the encapsulated value is an exception, it is raised instead of returned.</p> <p>If <code>timeout</code> is <code>None</code>, as default, the method will block until it gets a reply, potentially forever. If <code>timeout</code> is an integer or float, the method will wait for a reply for <code>timeout</code> seconds, and then raise <code>Timeout</code>.</p> <p>The encapsulated value can be retrieved multiple times. The future will only block the first time the value is accessed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>seconds to wait before timeout</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Timeout</code>             \u2013            <p>if timeout is reached</p> </li> <li> <code>Exception</code>             \u2013            <p>encapsulated value if it is an exception</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>encapsulated value if it is not an exception</p> </li> </ul> Source code in <code>src/pykka/_future.py</code> <pre><code>def get(\n    self,\n    *,\n    timeout: float | None = None,\n) -&gt; T:\n    \"\"\"Get the value encapsulated by the future.\n\n    If the encapsulated value is an exception, it is raised instead of\n    returned.\n\n    If `timeout` is `None`, as default, the method will block until it gets\n    a reply, potentially forever. If `timeout` is an integer or float, the\n    method will wait for a reply for `timeout` seconds, and then raise\n    [`Timeout`][pykka.Timeout].\n\n    The encapsulated value can be retrieved multiple times. The future will\n    only block the first time the value is accessed.\n\n    Args:\n        timeout: seconds to wait before timeout\n\n    Raises:\n        pykka.Timeout: if timeout is reached\n        Exception: encapsulated value if it is an exception\n\n    Returns:\n        encapsulated value if it is not an exception\n\n    \"\"\"\n    if self._get_hook is not None:\n        if isinstance(self._get_hook_result, _Unset):\n            self._get_hook_result = self._get_hook(timeout)\n        return self._get_hook_result\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/futures/#pykka.Future.join","title":"join","text":"<pre><code>join(*futures: Future[Any]) -&gt; Future[Iterable[Any]]\n</code></pre> <p>Return a new future with a list of the result of multiple futures.</p> <p>One or more futures can be passed as arguments to <code>join()</code>. The new future returns a list with the results from all the joined futures.</p> Example <pre><code>&gt;&gt;&gt; import pykka\n&gt;&gt;&gt; f1 = pykka.ThreadingFuture()\n&gt;&gt;&gt; f2 = pykka.ThreadingFuture()\n&gt;&gt;&gt; f3 = pykka.ThreadingFuture()\n&gt;&gt;&gt; f = f1.join(f2, f3)\n&gt;&gt;&gt; f1.set('abc')\n&gt;&gt;&gt; f2.set(123)\n&gt;&gt;&gt; f3.set(False)\n&gt;&gt;&gt; f.get()\n['abc', 123, False]\n</code></pre> <p>Version added: Pykka 1.2</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def join(\n    self: Future[Any],\n    *futures: Future[Any],\n) -&gt; Future[Iterable[Any]]:\n    \"\"\"Return a new future with a list of the result of multiple futures.\n\n    One or more futures can be passed as arguments to `join()`. The new\n    future returns a list with the results from all the joined futures.\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pykka\n        &gt;&gt;&gt; f1 = pykka.ThreadingFuture()\n        &gt;&gt;&gt; f2 = pykka.ThreadingFuture()\n        &gt;&gt;&gt; f3 = pykka.ThreadingFuture()\n        &gt;&gt;&gt; f = f1.join(f2, f3)\n        &gt;&gt;&gt; f1.set('abc')\n        &gt;&gt;&gt; f2.set(123)\n        &gt;&gt;&gt; f3.set(False)\n        &gt;&gt;&gt; f.get()\n        ['abc', 123, False]\n        ```\n\n    /// note | Version added: Pykka 1.2\n    ///\n\n    \"\"\"\n    future = cast(\"Future[Iterable[Any]]\", self.__class__())\n    future.set_get_hook(\n        lambda timeout: [f.get(timeout=timeout) for f in [self, *futures]]\n    )\n    return future\n</code></pre>"},{"location":"reference/futures/#pykka.Future.map","title":"map","text":"<pre><code>map(func: Callable[[T], M]) -&gt; Future[M]\n</code></pre> <p>Pass the result of the future through a function.</p> Example <pre><code>&gt;&gt;&gt; import pykka\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.map(lambda x: x + 10)\n&gt;&gt;&gt; f.set(30)\n&gt;&gt;&gt; g.get()\n40\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.map(lambda x: x['foo'])\n&gt;&gt;&gt; f.set({'foo': 'bar'}})\n&gt;&gt;&gt; g.get()\n'bar'\n</code></pre> <p>Version added: Pykka 1.2</p> <p>Version changed: Pykka 2.0</p> <p>Previously, if the future's result was an iterable (except a string), the function was applied to each item in the iterable. This behavior was unpredictable and made regular use cases like extracting a single field from a dict difficult, thus the behavior has been simplified. Since Pykka 2.0, the entire result value is passed to the function.</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def map(\n    self,\n    func: Callable[[T], M],\n) -&gt; Future[M]:\n    \"\"\"Pass the result of the future through a function.\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pykka\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.map(lambda x: x + 10)\n        &gt;&gt;&gt; f.set(30)\n        &gt;&gt;&gt; g.get()\n        40\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.map(lambda x: x['foo'])\n        &gt;&gt;&gt; f.set({'foo': 'bar'}})\n        &gt;&gt;&gt; g.get()\n        'bar'\n        ```\n\n    /// note | Version added: Pykka 1.2\n    ///\n\n    /// note | Version changed: Pykka 2.0\n    Previously, if the future's result was an iterable (except a\n    string), the function was applied to each item in the iterable.\n    This behavior was unpredictable and made regular use cases like\n    extracting a single field from a dict difficult, thus the\n    behavior has been simplified. Since Pykka 2.0, the entire result\n    value is passed to the function.\n    ///\n\n    \"\"\"\n    future = cast(\"Future[M]\", self.__class__())\n    future.set_get_hook(lambda timeout: func(self.get(timeout=timeout)))\n    return future\n</code></pre>"},{"location":"reference/futures/#pykka.Future.reduce","title":"reduce","text":"<pre><code>reduce(func: Callable[[R, J], R], *args: R) -&gt; Future[R]\n</code></pre> <p>Reduce a future's iterable result to a single value.</p> <p>The function of two arguments is applied cumulatively to the items of the iterable, from left to right. The result of the first function call is used as the first argument to the second function call, and so on, until the end of the iterable. If the future's value isn't an iterable, a <code>TypeError</code> is raised.</p> <p><code>reduce()</code> accepts an optional second argument, which will be used as an initial value in the first function call. If the iterable is empty, the initial value is returned.</p> Example <pre><code>&gt;&gt;&gt; import pykka\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n&gt;&gt;&gt; f.set(['a', 'b', 'c'])\n&gt;&gt;&gt; g.get()\n'abc'\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n&gt;&gt;&gt; f.set([1, 2, 3])\n&gt;&gt;&gt; (1 + 2) + 3\n6\n&gt;&gt;&gt; g.get()\n6\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n&gt;&gt;&gt; f.set([1, 2, 3])\n&gt;&gt;&gt; ((5 + 1) + 2) + 3\n11\n&gt;&gt;&gt; g.get()\n11\n\n&gt;&gt;&gt; f = pykka.ThreadingFuture()\n&gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n&gt;&gt;&gt; f.set([])\n&gt;&gt;&gt; g.get()\n5\n</code></pre> <p>Version added: Pykka 1.2</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def reduce(\n    self: Future[Iterable[J]],\n    func: Callable[[R, J], R],\n    *args: R,\n) -&gt; Future[R]:\n    \"\"\"Reduce a future's iterable result to a single value.\n\n    The function of two arguments is applied cumulatively to the items of\n    the iterable, from left to right. The result of the first function call\n    is used as the first argument to the second function call, and so on,\n    until the end of the iterable. If the future's value isn't an iterable,\n    a [`TypeError`][TypeError] is raised.\n\n    `reduce()` accepts an optional second argument, which will be used as an\n    initial value in the first function call. If the iterable is empty, the\n    initial value is returned.\n\n    Example:\n        ```pycon\n        &gt;&gt;&gt; import pykka\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n        &gt;&gt;&gt; f.set(['a', 'b', 'c'])\n        &gt;&gt;&gt; g.get()\n        'abc'\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y)\n        &gt;&gt;&gt; f.set([1, 2, 3])\n        &gt;&gt;&gt; (1 + 2) + 3\n        6\n        &gt;&gt;&gt; g.get()\n        6\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n        &gt;&gt;&gt; f.set([1, 2, 3])\n        &gt;&gt;&gt; ((5 + 1) + 2) + 3\n        11\n        &gt;&gt;&gt; g.get()\n        11\n\n        &gt;&gt;&gt; f = pykka.ThreadingFuture()\n        &gt;&gt;&gt; g = f.reduce(lambda x, y: x + y, 5)\n        &gt;&gt;&gt; f.set([])\n        &gt;&gt;&gt; g.get()\n        5\n        ```\n\n    /// note | Version added: Pykka 1.2\n    ///\n\n    \"\"\"\n    future = cast(\"Future[R]\", self.__class__())\n    future.set_get_hook(\n        lambda timeout: functools.reduce(func, self.get(timeout=timeout), *args)\n    )\n    return future\n</code></pre>"},{"location":"reference/futures/#pykka.Future.set","title":"set","text":"<pre><code>set(value: T | None = None) -&gt; None\n</code></pre> <p>Set the encapsulated value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>T | None</code>, default:                   <code>None</code> )           \u2013            <p>the encapsulated value or nothing</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>an exception if <code>set()</code> is called multiple times</p> </li> </ul> <p>Version changed: Pykka 4.3</p> <p>Calling <code>set()</code> on a future that already has a get hook set now raises an exception.</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def set(\n    self,\n    value: T | None = None,\n) -&gt; None:\n    \"\"\"Set the encapsulated value.\n\n    Args:\n        value: the encapsulated value or nothing\n\n    Raises:\n        Exception: an exception if `set()` is called multiple times\n\n    /// note | Version changed: Pykka 4.3\n    Calling `set()` on a future that already has a get hook set now\n    raises an exception.\n    ///\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/futures/#pykka.Future.set_exception","title":"set_exception","text":"<pre><code>set_exception(exc_info: OptExcInfo | None = None) -&gt; None\n</code></pre> <p>Set an exception as the encapsulated value.</p> <p>You can pass an <code>exc_info</code> three-tuple, as returned by <code>sys.exc_info()</code>. If you don't pass <code>exc_info</code>, <code>sys.exc_info()</code> will be called and the value returned by it used.</p> <p>In other words, if you're calling <code>set_exception()</code>, without any arguments, from an except block, the exception you're currently handling will automatically be set on the future.</p> <p>Parameters:</p> <ul> <li> <code>exc_info</code>               (<code>OptExcInfo | None</code>, default:                   <code>None</code> )           \u2013            <p>the encapsulated exception</p> </li> </ul> <p>Version changed: Pykka 4.3</p> <p>Calling <code>set_exception()</code> on a future that already has a get hook set now raises an exception.</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def set_exception(\n    self,\n    exc_info: OptExcInfo | None = None,\n) -&gt; None:\n    \"\"\"Set an exception as the encapsulated value.\n\n    You can pass an `exc_info` three-tuple, as returned by\n    [`sys.exc_info()`][sys.exc_info]. If you don't pass `exc_info`,\n    [`sys.exc_info()`][sys.exc_info] will be called and the value returned\n    by it used.\n\n    In other words, if you're calling `set_exception()`, without any\n    arguments, from an except block, the exception you're currently handling\n    will automatically be set on the future.\n\n    Args:\n        exc_info: the encapsulated exception\n\n    /// note | Version changed: Pykka 4.3\n    Calling `set_exception()` on a future that already has a get hook\n    set now raises an exception.\n    ///\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/futures/#pykka.Future.set_get_hook","title":"set_get_hook","text":"<pre><code>set_get_hook(func: GetHookFunc[T]) -&gt; None\n</code></pre> <p>Set a function to be executed when <code>get()</code> is called.</p> <p>The function will be called when <code>get()</code> is called, with the <code>timeout</code> value as the only argument. The function's return value will be returned from <code>get()</code>.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>GetHookFunc[T]</code>)           \u2013            <p>callable accepting a timeout value, to produce return value of <code>get()</code></p> </li> </ul> <p>Version added: Pykka 1.2</p> <p>Version changed: Pykka 4.3</p> <p>Calling <code>set_get_hook()</code> on a future that already has a result set now raises an exception.</p> Source code in <code>src/pykka/_future.py</code> <pre><code>def set_get_hook(\n    self,\n    func: GetHookFunc[T],\n) -&gt; None:\n    \"\"\"Set a function to be executed when [`get()`][pykka.Future.get] is called.\n\n    The function will be called when [`get()`][pykka.Future.get] is called, with the\n    `timeout` value as the only argument. The function's return value will\n    be returned from [`get()`][pykka.Future.get].\n\n    Args:\n        func: callable accepting a timeout value, to produce return value of\n            `get()`\n\n    /// note | Version added: Pykka 1.2\n    ///\n\n    /// note | Version changed: Pykka 4.3\n    Calling `set_get_hook()` on a future that already has a result set\n    now raises an exception.\n    ///\n\n    \"\"\"\n    self._get_hook = func\n</code></pre>"},{"location":"reference/futures/#pykka.get_all","title":"pykka.get_all","text":"<pre><code>get_all(\n    futures: Iterable[Future[T]],\n    *,\n    timeout: float | None = None,\n) -&gt; Iterable[T]\n</code></pre> <p>Collect all values encapsulated in the list of futures.</p> <p>If <code>timeout</code> is not <code>None</code>, the method will wait for a reply for <code>timeout</code> seconds, and then raise <code>pykka.Timeout</code>.</p> <p>Parameters:</p> <ul> <li> <code>futures</code>               (<code>Iterable[Future[T]]</code>)           \u2013            <p>futures for the results to collect</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>seconds to wait before timeout</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Timeout</code>             \u2013            <p>if timeout is reached</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[T]</code>           \u2013            <p>list of results</p> </li> </ul> Source code in <code>src/pykka/_future.py</code> <pre><code>def get_all(\n    futures: Iterable[Future[T]],\n    *,\n    timeout: float | None = None,\n) -&gt; Iterable[T]:\n    \"\"\"Collect all values encapsulated in the list of futures.\n\n    If `timeout` is not `None`, the method will wait for a reply for\n    `timeout` seconds, and then raise [`pykka.Timeout`][pykka.Timeout].\n\n    Args:\n        futures: futures for the results to collect\n        timeout: seconds to wait before timeout\n\n    Raises:\n        pykka.Timeout: if timeout is reached\n\n    Returns:\n        list of results\n\n    \"\"\"\n    return [future.get(timeout=timeout) for future in futures]\n</code></pre>"},{"location":"reference/messages/","title":"Message objects","text":""},{"location":"reference/messages/#pykka.messages","title":"pykka.messages","text":"<p>The <code>pykka.messages</code> module contains Pykka's own actor messages.</p> <p>In general, you should not need to use any of these classes. However, they have been made part of the public API so that certain optimizations can be done without touching Pykka's internals.</p> <p>An example is to combine <code>ask()</code> and <code>ProxyCall</code> to call a method on an actor without having to spend any resources on creating a proxy object:</p> <pre><code>reply = actor_ref.ask(\n    ProxyCall(\n        attr_path=['my_method'],\n        args=['foo'],\n        kwargs={'bar': 'baz'}\n    )\n)\n</code></pre> <p>Another example is to use <code>tell()</code> instead of <code>ask()</code> for the proxy method call, and thus avoid the creation of a future for the return value if you don't need it.</p> <p>It should be noted that these optimizations should only be necessary in very special circumstances.</p>"},{"location":"reference/messages/#pykka.messages.ProxyCall","title":"ProxyCall","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Message to ask the actor to call the method with the arguments.</p> <p>Version added: Pykka 2.0</p> Source code in <code>src/pykka/messages.py</code> <pre><code>class ProxyCall(NamedTuple):\n    \"\"\"Message to ask the actor to call the method with the arguments.\n\n    /// note | Version added: Pykka 2.0\n    ///\n    \"\"\"\n\n    #: List with the path from the actor to the method.\n    attr_path: AttrPath\n\n    #: List with positional arguments.\n    args: tuple[Any, ...]\n\n    #: Dict with keyword arguments.\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"reference/messages/#pykka.messages.ProxyGetAttr","title":"ProxyGetAttr","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Message to ask the actor to return the value of the attribute.</p> <p>Version added: Pykka 2.0</p> Source code in <code>src/pykka/messages.py</code> <pre><code>class ProxyGetAttr(NamedTuple):\n    \"\"\"Message to ask the actor to return the value of the attribute.\n\n    /// note | Version added: Pykka 2.0\n    ///\n    \"\"\"\n\n    #: List with the path from the actor to the attribute.\n    attr_path: AttrPath\n</code></pre>"},{"location":"reference/messages/#pykka.messages.ProxySetAttr","title":"ProxySetAttr","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Message to ask the actor to set the attribute to the value.</p> <p>Version added: Pykka 2.0</p> Source code in <code>src/pykka/messages.py</code> <pre><code>class ProxySetAttr(NamedTuple):\n    \"\"\"Message to ask the actor to set the attribute to the value.\n\n    /// note | Version added: Pykka 2.0\n    ///\n    \"\"\"\n\n    #: List with the path from the actor to the attribute.\n    attr_path: AttrPath\n\n    #: The value to set the attribute to.\n    value: Any\n</code></pre>"},{"location":"reference/proxies/","title":"Proxies","text":""},{"location":"reference/proxies/#pykka.ActorProxy","title":"pykka.ActorProxy","text":"<p>               Bases: <code>Generic[A]</code></p> <p>A proxy object for an actor's attributes and methods, via an <code>ActorRef</code>.</p> <p>The proxy allows the referenced actor to be used through regular method calls and field access.</p>"},{"location":"reference/proxies/#pykka.ActorProxy--creating-a-proxy","title":"Creating a proxy","text":"<p>You can create an <code>ActorProxy</code> from any <code>ActorRef</code>:</p> <pre><code>actor_ref = MyActor.start()\nactor_proxy = ActorProxy(actor_ref)\n</code></pre> <p>You can also get an <code>ActorProxy</code> by using <code>proxy()</code>:</p> <pre><code>actor_proxy = MyActor.start().proxy()\n</code></pre>"},{"location":"reference/proxies/#pykka.ActorProxy--attributes-and-method-calls","title":"Attributes and method calls","text":"<p>When reading an attribute or getting a return value from a method, you get a <code>Future</code> object back. To get the enclosed value from the future, you must call <code>get()</code> on the returned future:</p> <pre><code>print(actor_proxy.string_attribute.get())\nprint(actor_proxy.count().get() + 1)\n</code></pre> <p>If you call a method just for it's side effects and do not care about the return value, you do not need to accept the returned future or call <code>get()</code> on the future. Simply call the method, and it will be executed concurrently with your own code:</p> <pre><code>actor_proxy.method_with_side_effect()\n</code></pre> <p>If you want to block your own code from continuing while the other method is processing, you can use <code>get()</code> to block until it completes::</p> <pre><code>actor_proxy.method_with_side_effect().get()\n</code></pre> <p>You can also use the <code>await</code> keyword to block until the method completes:</p> <pre><code>await actor_proxy.method_with_side_effect()\n</code></pre> <p>If you access a proxied method as an attribute, without calling it, you get an <code>CallableProxy</code>.</p>"},{"location":"reference/proxies/#pykka.ActorProxy--proxy-to-itself","title":"Proxy to itself","text":"<p>An actor can use a proxy to itself to schedule work for itself. The scheduled work will only be done after the current message and all messages already in the inbox are processed.</p> <p>For example, if an actor can split a time consuming task into multiple parts, and after completing each part can ask itself to start on the next part using proxied calls or messages to itself, it can react faster to other incoming messages as they will be interleaved with the parts of the time consuming task. This is especially useful for being able to stop the actor in the middle of a time consuming task.</p> <p>To create a proxy to yourself, use the actor's <code>actor_ref</code> attribute:</p> <pre><code>proxy_to_myself_in_the_future = self.actor_ref.proxy()\n</code></pre> <p>If you create a proxy in your actor's constructor or <code>on_start()</code> method, you can create a nice API for deferring work to yourself in the future:</p> <pre><code>def __init__(self):\n    ...\n    self._in_future = self.actor_ref.proxy()\n    ...\n\ndef do_work(self):\n    ...\n    self._in_future.do_more_work()\n    ...\n\ndef do_more_work(self):\n    ...\n</code></pre> <p>To avoid infinite loops during proxy introspection, proxies to self should be kept as private instance attributes by prefixing the attribute name with <code>_</code>.</p> Example examples/cooperation.py<pre><code>#!/usr/bin/env python3\n# /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = [\n#     \"pykka\",\n# ]\n# ///\n\nimport pykka\n\n\nclass Adder(pykka.ThreadingActor):\n    def add_one(self, i: int) -&gt; int:\n        print(f\"Adder is adding 1 to {i}\")\n        return i + 1\n\n\nclass Bookkeeper(pykka.ThreadingActor):\n    def __init__(self, adder: pykka.ActorProxy[Adder]) -&gt; None:\n        super().__init__()\n        self.adder = adder\n\n    def count_to(self, target: int) -&gt; None:\n        i = 0\n        while i &lt; target:\n            i = self.adder.add_one(i).get()\n            print(f\"Bookkeeper got {i} back\")\n\n\nif __name__ == \"__main__\":\n    # Start the adder actor\n    adder = Adder.start().proxy()\n\n    # Start the bookkeeper actor, passing it the adder actor's proxy\n    bookkeeper = Bookkeeper.start(adder).proxy()\n\n    # Ask the bookkeeper to count to 5\n    bookkeeper.count_to(5).get()\n\n    # Stop all running actors using the ActorRegistry\n    pykka.ActorRegistry.stop_all()\n</code></pre> <p>Parameters:</p> <ul> <li> <code>actor_ref</code>               (<code>ActorRef[A]</code>)           \u2013            <p>reference to the actor to proxy</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ActorDeadError</code>             \u2013            <p>if the actor is not alive</p> </li> </ul> Source code in <code>src/pykka/_proxy.py</code> <pre><code>class ActorProxy(Generic[A]):\n    \"\"\"A proxy object for an actor's attributes and methods, via an `ActorRef`.\n\n    The proxy allows the referenced actor to be used through regular\n    method calls and field access.\n\n    # Creating a proxy\n\n    You can create an [`ActorProxy`][pykka.ActorProxy] from any\n    [`ActorRef`][pykka.ActorRef]:\n\n        actor_ref = MyActor.start()\n        actor_proxy = ActorProxy(actor_ref)\n\n    You can also get an [`ActorProxy`][pykka.ActorProxy] by using\n    [`proxy()`][pykka.ActorRef.proxy]:\n\n        actor_proxy = MyActor.start().proxy()\n\n    # Attributes and method calls\n\n    When reading an attribute or getting a return value from a method, you get a\n    [`Future`][pykka.Future] object back. To get the enclosed value from the\n    future, you must call [`get()`][pykka.Future.get] on the returned future:\n\n        print(actor_proxy.string_attribute.get())\n        print(actor_proxy.count().get() + 1)\n\n    If you call a method just for it's side effects and do not care about the\n    return value, you do not need to accept the returned future or call\n    [`get()`][pykka.Future.get] on the future. Simply call the method, and it\n    will be executed concurrently with your own code:\n\n        actor_proxy.method_with_side_effect()\n\n    If you want to block your own code from continuing while the other method\n    is processing, you can use [`get()`][pykka.Future.get] to block until it\n    completes::\n\n        actor_proxy.method_with_side_effect().get()\n\n    You can also use the `await` keyword to block until the method completes:\n\n        await actor_proxy.method_with_side_effect()\n\n    If you access a proxied method as an attribute, without calling it, you\n    get an [`CallableProxy`][pykka.CallableProxy].\n\n    # Proxy to itself\n\n    An actor can use a proxy to itself to schedule work for itself. The\n    scheduled work will only be done after the current message and all messages\n    already in the inbox are processed.\n\n    For example, if an actor can split a time consuming task into multiple\n    parts, and after completing each part can ask itself to start on the next\n    part using proxied calls or messages to itself, it can react faster to\n    other incoming messages as they will be interleaved with the parts of the\n    time consuming task. This is especially useful for being able to stop the\n    actor in the middle of a time consuming task.\n\n    To create a proxy to yourself, use the actor's\n    [`actor_ref`][pykka.Actor.actor_ref] attribute:\n\n        proxy_to_myself_in_the_future = self.actor_ref.proxy()\n\n    If you create a proxy in your actor's constructor or\n    [`on_start()`][pykka.Actor.on_start] method, you can create a nice API for\n    deferring work to yourself in the future:\n\n        def __init__(self):\n            ...\n            self._in_future = self.actor_ref.proxy()\n            ...\n\n        def do_work(self):\n            ...\n            self._in_future.do_more_work()\n            ...\n\n        def do_more_work(self):\n            ...\n\n    To avoid infinite loops during proxy introspection, proxies to self\n    should be kept as private instance attributes by prefixing the attribute\n    name with `_`.\n\n    Example:\n        ```title=\"examples/cooperation.py\"\n        --8&lt;-- \"examples/cooperation.py\"\n        ```\n\n    Args:\n        actor_ref: reference to the actor to proxy\n\n    Raises:\n        pykka.ActorDeadError: if the actor is not alive\n\n    \"\"\"\n\n    #: The actor's :class:`pykka.ActorRef` instance.\n    actor_ref: ActorRef[A]\n\n    _actor: A\n    _attr_path: AttrPath\n    _known_attrs: dict[AttrPath, AttrInfo]\n    _actor_proxies: dict[AttrPath, ActorProxy[A]]\n    _callable_proxies: dict[AttrPath, CallableProxy[A]]\n\n    def __init__(\n        self,\n        *,\n        actor_ref: ActorRef[A],\n        attr_path: AttrPath | None = None,\n    ) -&gt; None:\n        if not actor_ref.is_alive():\n            msg = f\"{actor_ref} not found\"\n            raise ActorDeadError(msg)\n        self.actor_ref = actor_ref\n        self._actor = actor_ref._actor  # noqa: SLF001\n        self._attr_path = attr_path or ()\n        self._known_attrs = introspect_attrs(root=self._actor, proxy=self)\n        self._actor_proxies = {}\n        self._callable_proxies = {}\n\n    def __eq__(\n        self,\n        other: object,\n    ) -&gt; bool:\n        if not isinstance(other, ActorProxy):\n            return False\n        if self._actor != other._actor:  # pyright: ignore[reportUnknownMemberType]\n            return False\n        return self._attr_path == other._attr_path\n\n    def __hash__(self) -&gt; int:\n        return hash((self._actor, self._attr_path))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;ActorProxy for {self.actor_ref}, attr_path={self._attr_path!r}&gt;\"\n\n    def __dir__(self) -&gt; list[str]:\n        result = [\"__class__\"]\n        result += list(self.__class__.__dict__.keys())\n        result += list(self.__dict__.keys())\n        result += [attr_path[0] for attr_path in list(self._known_attrs.keys())]\n        return sorted(result)\n\n    def __getattr__(self, name: str) -&gt; Any:\n        \"\"\"Get a field or callable from the actor.\"\"\"\n        attr_path: AttrPath = (*self._attr_path, name)\n\n        if attr_path not in self._known_attrs:\n            self._known_attrs = introspect_attrs(root=self._actor, proxy=self)\n\n        attr_info = self._known_attrs.get(attr_path)\n        if attr_info is None:\n            msg = f\"{self} has no attribute {name!r}\"\n            raise AttributeError(msg)\n\n        if attr_info.callable:\n            if attr_path not in self._callable_proxies:\n                self._callable_proxies[attr_path] = CallableProxy(\n                    actor_ref=self.actor_ref,\n                    attr_path=attr_path,\n                )\n            return self._callable_proxies[attr_path]\n\n        if attr_info.traversable:\n            if attr_path not in self._actor_proxies:\n                self._actor_proxies[attr_path] = ActorProxy(\n                    actor_ref=self.actor_ref,\n                    attr_path=attr_path,\n                )\n            return self._actor_proxies[attr_path]\n\n        message = messages.ProxyGetAttr(attr_path=attr_path)\n        return self.actor_ref.ask(message, block=False)\n\n    def __setattr__(\n        self,\n        name: str,\n        value: Any,\n    ) -&gt; None:\n        \"\"\"Set a field on the actor.\n\n        Blocks until the field is set to check if any exceptions was raised.\n        \"\"\"\n        if name == \"actor_ref\" or name.startswith(\"_\"):\n            return super().__setattr__(name, value)\n        attr_path = (*self._attr_path, name)\n        message = messages.ProxySetAttr(attr_path=attr_path, value=value)\n        self.actor_ref.ask(message)\n        return None\n</code></pre>"},{"location":"reference/proxies/#pykka.ActorProxy.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Get a field or callable from the actor.</p> Source code in <code>src/pykka/_proxy.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"Get a field or callable from the actor.\"\"\"\n    attr_path: AttrPath = (*self._attr_path, name)\n\n    if attr_path not in self._known_attrs:\n        self._known_attrs = introspect_attrs(root=self._actor, proxy=self)\n\n    attr_info = self._known_attrs.get(attr_path)\n    if attr_info is None:\n        msg = f\"{self} has no attribute {name!r}\"\n        raise AttributeError(msg)\n\n    if attr_info.callable:\n        if attr_path not in self._callable_proxies:\n            self._callable_proxies[attr_path] = CallableProxy(\n                actor_ref=self.actor_ref,\n                attr_path=attr_path,\n            )\n        return self._callable_proxies[attr_path]\n\n    if attr_info.traversable:\n        if attr_path not in self._actor_proxies:\n            self._actor_proxies[attr_path] = ActorProxy(\n                actor_ref=self.actor_ref,\n                attr_path=attr_path,\n            )\n        return self._actor_proxies[attr_path]\n\n    message = messages.ProxyGetAttr(attr_path=attr_path)\n    return self.actor_ref.ask(message, block=False)\n</code></pre>"},{"location":"reference/proxies/#pykka.ActorProxy.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> <p>Set a field on the actor.</p> <p>Blocks until the field is set to check if any exceptions was raised.</p> Source code in <code>src/pykka/_proxy.py</code> <pre><code>def __setattr__(\n    self,\n    name: str,\n    value: Any,\n) -&gt; None:\n    \"\"\"Set a field on the actor.\n\n    Blocks until the field is set to check if any exceptions was raised.\n    \"\"\"\n    if name == \"actor_ref\" or name.startswith(\"_\"):\n        return super().__setattr__(name, value)\n    attr_path = (*self._attr_path, name)\n    message = messages.ProxySetAttr(attr_path=attr_path, value=value)\n    self.actor_ref.ask(message)\n    return None\n</code></pre>"},{"location":"reference/proxies/#pykka.CallableProxy","title":"pykka.CallableProxy","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Proxy to a single method.</p> <p><code>CallableProxy</code> instances are returned when accessing methods on a <code>ActorProxy</code> without calling them.</p> Example <pre><code>proxy = AnActor.start().proxy()\n\n# Ask semantics returns a future. See `__call__()` docs.\nfuture = proxy.do_work()\n\n# Tell semantics are fire and forget. See `defer()` docs.\nproxy.do_work.defer()\n</code></pre> Source code in <code>src/pykka/_proxy.py</code> <pre><code>class CallableProxy(Generic[A]):\n    \"\"\"Proxy to a single method.\n\n    [`CallableProxy`][pykka.CallableProxy] instances are returned when accessing\n    methods on a [`ActorProxy`][pykka.ActorProxy] without calling them.\n\n    Example:\n        ```py\n        proxy = AnActor.start().proxy()\n\n        # Ask semantics returns a future. See `__call__()` docs.\n        future = proxy.do_work()\n\n        # Tell semantics are fire and forget. See `defer()` docs.\n        proxy.do_work.defer()\n        ```\n\n    \"\"\"\n\n    actor_ref: ActorRef[A]\n    _attr_path: AttrPath\n\n    def __init__(\n        self,\n        *,\n        actor_ref: ActorRef[A],\n        attr_path: AttrPath,\n    ) -&gt; None:\n        self.actor_ref = actor_ref\n        self._attr_path = attr_path\n\n    def __call__(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Future[Any]:\n        \"\"\"Call with [`ask()`][pykka.ActorRef.ask] semantics.\n\n        Returns a future which will yield the called method's return value.\n\n        If the call raises an exception it is set on the future, and the exception is\n        reraised by [`get()`][pykka.Future.get]. If the future is left unused,\n        the exception will not be reraised. Either way, the exception will\n        also be logged. See the logging section in the docs for details.\n        \"\"\"\n        message = messages.ProxyCall(\n            attr_path=self._attr_path, args=args, kwargs=kwargs\n        )\n        return self.actor_ref.ask(message, block=False)\n\n    def defer(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Call with [`tell()`][pykka.ActorRef.tell] semantics.\n\n        Does not create or return a future.\n\n        If the call raises an exception, there is no future to set the\n        exception on. Thus, the actor's [`on_failure()`][pykka.Actor.on_failure]\n        hook is called instead.\n\n        /// note | Version added: Pykka 2.0\n        ///\n        \"\"\"\n        message = messages.ProxyCall(\n            attr_path=self._attr_path, args=args, kwargs=kwargs\n        )\n        self.actor_ref.tell(message)\n</code></pre>"},{"location":"reference/proxies/#pykka.CallableProxy.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwargs: Any) -&gt; Future[Any]\n</code></pre> <p>Call with <code>ask()</code> semantics.</p> <p>Returns a future which will yield the called method's return value.</p> <p>If the call raises an exception it is set on the future, and the exception is reraised by <code>get()</code>. If the future is left unused, the exception will not be reraised. Either way, the exception will also be logged. See the logging section in the docs for details.</p> Source code in <code>src/pykka/_proxy.py</code> <pre><code>def __call__(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[Any]:\n    \"\"\"Call with [`ask()`][pykka.ActorRef.ask] semantics.\n\n    Returns a future which will yield the called method's return value.\n\n    If the call raises an exception it is set on the future, and the exception is\n    reraised by [`get()`][pykka.Future.get]. If the future is left unused,\n    the exception will not be reraised. Either way, the exception will\n    also be logged. See the logging section in the docs for details.\n    \"\"\"\n    message = messages.ProxyCall(\n        attr_path=self._attr_path, args=args, kwargs=kwargs\n    )\n    return self.actor_ref.ask(message, block=False)\n</code></pre>"},{"location":"reference/proxies/#pykka.CallableProxy.defer","title":"defer","text":"<pre><code>defer(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Call with <code>tell()</code> semantics.</p> <p>Does not create or return a future.</p> <p>If the call raises an exception, there is no future to set the exception on. Thus, the actor's <code>on_failure()</code> hook is called instead.</p> <p>Version added: Pykka 2.0</p> Source code in <code>src/pykka/_proxy.py</code> <pre><code>def defer(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Call with [`tell()`][pykka.ActorRef.tell] semantics.\n\n    Does not create or return a future.\n\n    If the call raises an exception, there is no future to set the\n    exception on. Thus, the actor's [`on_failure()`][pykka.Actor.on_failure]\n    hook is called instead.\n\n    /// note | Version added: Pykka 2.0\n    ///\n    \"\"\"\n    message = messages.ProxyCall(\n        attr_path=self._attr_path, args=args, kwargs=kwargs\n    )\n    self.actor_ref.tell(message)\n</code></pre>"},{"location":"reference/proxies/#pykka.traversable","title":"pykka.traversable","text":"<pre><code>traversable(obj: T) -&gt; T\n</code></pre> <p>Mark an actor attribute as traversable.</p> <p>The traversable marker makes the actor attribute's own methods and attributes available to users of the actor through an <code>ActorProxy</code>.</p> <p>Used as a function to mark a single attribute:</p> <pre><code>class AnActor(pykka.ThreadingActor):\n    playback = pykka.traversable(Playback())\n\nclass Playback(object):\n    def play(self):\n        return True\n</code></pre> <p>This function can also be used as a class decorator, making all instances of the class traversable:</p> <pre><code>class AnActor(pykka.ThreadingActor):\n    playback = Playback()\n\n@pykka.traversable\nclass Playback(object):\n    def play(self):\n        return True\n</code></pre> <p>The third alternative, and the only way in Pykka &lt; 2.0, is to manually mark a class as traversable by setting the <code>pykka_traversable</code> attribute to :class:<code>True</code>:</p> <pre><code>class AnActor(pykka.ThreadingActor):\n    playback = Playback()\n\nclass Playback(object):\n    pykka_traversable = True\n\n    def play(self):\n        return True\n</code></pre> <p>When the attribute is marked as traversable, its methods can be executed in the context of the actor through an actor proxy::</p> <pre><code>proxy = AnActor.start().proxy()\nassert proxy.playback.play().get() is True\n</code></pre> <p>Version added: Pykka 2.0</p> Source code in <code>src/pykka/_proxy.py</code> <pre><code>def traversable(obj: T) -&gt; T:\n    \"\"\"Mark an actor attribute as traversable.\n\n    The traversable marker makes the actor attribute's own methods and\n    attributes available to users of the actor through an\n    [`ActorProxy`][pykka.ActorProxy].\n\n    Used as a function to mark a single attribute:\n\n        class AnActor(pykka.ThreadingActor):\n            playback = pykka.traversable(Playback())\n\n        class Playback(object):\n            def play(self):\n                return True\n\n    This function can also be used as a class decorator, making all instances\n    of the class traversable:\n\n        class AnActor(pykka.ThreadingActor):\n            playback = Playback()\n\n        @pykka.traversable\n        class Playback(object):\n            def play(self):\n                return True\n\n    The third alternative, and the only way in Pykka &lt; 2.0, is to manually\n    mark a class as traversable by setting the ``pykka_traversable`` attribute\n    to :class:`True`:\n\n        class AnActor(pykka.ThreadingActor):\n            playback = Playback()\n\n        class Playback(object):\n            pykka_traversable = True\n\n            def play(self):\n                return True\n\n    When the attribute is marked as traversable, its methods can be executed\n    in the context of the actor through an actor proxy::\n\n        proxy = AnActor.start().proxy()\n        assert proxy.playback.play().get() is True\n\n    /// note | Version added: Pykka 2.0\n    ///\n    \"\"\"\n    if hasattr(obj, \"__slots__\"):\n        msg = (\n            \"pykka.traversable() cannot be used to mark \"\n            \"an object using slots as traversable.\"\n        )\n        raise ValueError(msg)\n    obj._pykka_traversable = True  # type: ignore[attr-defined]  # noqa: SLF001\n    return obj\n</code></pre>"},{"location":"reference/registry/","title":"Registry","text":""},{"location":"reference/registry/#pykka.ActorRegistry","title":"pykka.ActorRegistry","text":"<p>Registry which provides easy access to all running actors.</p> <p>Contains global state, but should be thread-safe.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>class ActorRegistry:\n    \"\"\"Registry which provides easy access to all running actors.\n\n    Contains global state, but should be thread-safe.\n    \"\"\"\n\n    _actor_refs: ClassVar[list[ActorRef[Any]]] = []\n    _actor_refs_lock: ClassVar[threading.RLock] = threading.RLock()\n\n    @classmethod\n    def broadcast(\n        cls,\n        message: Any,\n        target_class: str | type[Actor] | None = None,\n    ) -&gt; None:\n        \"\"\"Broadcast `message` to all actors of the specified `target_class`.\n\n        If no `target_class` is specified, the message is broadcasted to all\n        actors.\n\n        Args:\n            message: the message to send\n            target_class: optional actor class or class name\n\n        \"\"\"\n        if isinstance(target_class, str):\n            targets = cls.get_by_class_name(target_class)\n        elif target_class is not None:\n            targets = cls.get_by_class(target_class)\n        else:\n            targets = cls.get_all()\n        for ref in targets:\n            ref.tell(message)\n\n    @classmethod\n    def get_all(cls) -&gt; list[ActorRef[Any]]:\n        \"\"\"Get all running actors.\"\"\"\n        with cls._actor_refs_lock:\n            return cls._actor_refs[:]\n\n    @classmethod\n    def get_by_class(\n        cls,\n        actor_class: type[A],\n    ) -&gt; list[ActorRef[A]]:\n        \"\"\"Get all running actors of the given class or a subclass.\n\n        Args:\n            actor_class: actor class, or any superclass of the actor\n\n        \"\"\"\n        with cls._actor_refs_lock:\n            return [\n                ref\n                for ref in cls._actor_refs\n                if issubclass(ref.actor_class, actor_class)\n            ]\n\n    @classmethod\n    def get_by_class_name(\n        cls,\n        actor_class_name: str,\n    ) -&gt; list[ActorRef[Any]]:\n        \"\"\"Get all running actors of the given class name.\"\"\"\n        with cls._actor_refs_lock:\n            return [\n                ref\n                for ref in cls._actor_refs\n                if ref.actor_class.__name__ == actor_class_name\n            ]\n\n    @classmethod\n    def get_by_urn(\n        cls,\n        actor_urn: str,\n    ) -&gt; ActorRef[Any] | None:\n        \"\"\"Get an actor by its universally unique URN.\"\"\"\n        with cls._actor_refs_lock:\n            refs = [ref for ref in cls._actor_refs if ref.actor_urn == actor_urn]\n            if not refs:\n                return None\n            return refs[0]\n\n    @classmethod\n    def register(\n        cls,\n        actor_ref: ActorRef[Any],\n    ) -&gt; None:\n        \"\"\"Register an [`ActorRef`][pykka.ActorRef] in the registry.\n\n        This is done automatically when an actor is started, e.g. by calling\n        [`Actor.start()`][pykka.Actor.start].\n        \"\"\"\n        with cls._actor_refs_lock:\n            cls._actor_refs.append(actor_ref)\n        logger.debug(f\"Registered {actor_ref}\")\n\n    @overload\n    @classmethod\n    def stop_all(\n        cls,\n        *,\n        block: Literal[True],\n        timeout: float | None = ...,\n    ) -&gt; list[bool]: ...\n\n    @overload\n    @classmethod\n    def stop_all(\n        cls,\n        *,\n        block: Literal[False],\n        timeout: float | None = ...,\n    ) -&gt; list[Future[bool]]: ...\n\n    @overload\n    @classmethod\n    def stop_all(\n        cls,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; list[bool] | list[Future[bool]]: ...\n\n    @classmethod\n    def stop_all(\n        cls,\n        *,\n        block: bool = True,\n        timeout: float | None = None,\n    ) -&gt; list[bool] | list[Future[bool]]:\n        \"\"\"Stop all running actors.\n\n        `block` and `timeout` works as for\n        [`ActorRef.stop()`][pykka.ActorRef.stop].\n\n        If `block` is `True`, the actors are guaranteed to be stopped\n        in the reverse of the order they were started in. This is helpful if\n        you have simple dependencies in between your actors, where it is\n        sufficient to shut down actors in a LIFO manner: last started, first\n        stopped.\n\n        If you have more complex dependencies in between your actors, you\n        should take care to shut them down in the required order yourself, e.g.\n        by stopping dependees from a dependency's\n        [`on_stop()`][pykka.Actor.on_stop] method.\n\n        Returns:\n            a list with the return values for each stop action\n\n        \"\"\"\n        return [\n            ref.stop(block=block, timeout=timeout) for ref in reversed(cls.get_all())\n        ]\n\n    @classmethod\n    def unregister(\n        cls,\n        actor_ref: ActorRef[A],\n    ) -&gt; None:\n        \"\"\"Remove an [`ActorRef`][pykka.ActorRef] from the registry.\n\n        This is done automatically when an actor is stopped, e.g. by calling\n        [`Actor.stop()`][pykka.Actor.stop].\n        \"\"\"\n        removed = False\n        with cls._actor_refs_lock:\n            if actor_ref in cls._actor_refs:\n                cls._actor_refs.remove(actor_ref)\n                removed = True\n        if removed:\n            logger.debug(f\"Unregistered {actor_ref}\")\n        else:\n            logger.debug(f\"Unregistered {actor_ref} (not found in registry)\")\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.broadcast","title":"broadcast  <code>classmethod</code>","text":"<pre><code>broadcast(\n    message: Any,\n    target_class: str | type[Actor] | None = None,\n) -&gt; None\n</code></pre> <p>Broadcast <code>message</code> to all actors of the specified <code>target_class</code>.</p> <p>If no <code>target_class</code> is specified, the message is broadcasted to all actors.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Any</code>)           \u2013            <p>the message to send</p> </li> <li> <code>target_class</code>               (<code>str | type[Actor] | None</code>, default:                   <code>None</code> )           \u2013            <p>optional actor class or class name</p> </li> </ul> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef broadcast(\n    cls,\n    message: Any,\n    target_class: str | type[Actor] | None = None,\n) -&gt; None:\n    \"\"\"Broadcast `message` to all actors of the specified `target_class`.\n\n    If no `target_class` is specified, the message is broadcasted to all\n    actors.\n\n    Args:\n        message: the message to send\n        target_class: optional actor class or class name\n\n    \"\"\"\n    if isinstance(target_class, str):\n        targets = cls.get_by_class_name(target_class)\n    elif target_class is not None:\n        targets = cls.get_by_class(target_class)\n    else:\n        targets = cls.get_all()\n    for ref in targets:\n        ref.tell(message)\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.get_all","title":"get_all  <code>classmethod</code>","text":"<pre><code>get_all() -&gt; list[ActorRef[Any]]\n</code></pre> <p>Get all running actors.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef get_all(cls) -&gt; list[ActorRef[Any]]:\n    \"\"\"Get all running actors.\"\"\"\n    with cls._actor_refs_lock:\n        return cls._actor_refs[:]\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.get_by_class","title":"get_by_class  <code>classmethod</code>","text":"<pre><code>get_by_class(actor_class: type[A]) -&gt; list[ActorRef[A]]\n</code></pre> <p>Get all running actors of the given class or a subclass.</p> <p>Parameters:</p> <ul> <li> <code>actor_class</code>               (<code>type[A]</code>)           \u2013            <p>actor class, or any superclass of the actor</p> </li> </ul> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef get_by_class(\n    cls,\n    actor_class: type[A],\n) -&gt; list[ActorRef[A]]:\n    \"\"\"Get all running actors of the given class or a subclass.\n\n    Args:\n        actor_class: actor class, or any superclass of the actor\n\n    \"\"\"\n    with cls._actor_refs_lock:\n        return [\n            ref\n            for ref in cls._actor_refs\n            if issubclass(ref.actor_class, actor_class)\n        ]\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.get_by_class_name","title":"get_by_class_name  <code>classmethod</code>","text":"<pre><code>get_by_class_name(\n    actor_class_name: str,\n) -&gt; list[ActorRef[Any]]\n</code></pre> <p>Get all running actors of the given class name.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef get_by_class_name(\n    cls,\n    actor_class_name: str,\n) -&gt; list[ActorRef[Any]]:\n    \"\"\"Get all running actors of the given class name.\"\"\"\n    with cls._actor_refs_lock:\n        return [\n            ref\n            for ref in cls._actor_refs\n            if ref.actor_class.__name__ == actor_class_name\n        ]\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.get_by_urn","title":"get_by_urn  <code>classmethod</code>","text":"<pre><code>get_by_urn(actor_urn: str) -&gt; ActorRef[Any] | None\n</code></pre> <p>Get an actor by its universally unique URN.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef get_by_urn(\n    cls,\n    actor_urn: str,\n) -&gt; ActorRef[Any] | None:\n    \"\"\"Get an actor by its universally unique URN.\"\"\"\n    with cls._actor_refs_lock:\n        refs = [ref for ref in cls._actor_refs if ref.actor_urn == actor_urn]\n        if not refs:\n            return None\n        return refs[0]\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(actor_ref: ActorRef[Any]) -&gt; None\n</code></pre> <p>Register an <code>ActorRef</code> in the registry.</p> <p>This is done automatically when an actor is started, e.g. by calling <code>Actor.start()</code>.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef register(\n    cls,\n    actor_ref: ActorRef[Any],\n) -&gt; None:\n    \"\"\"Register an [`ActorRef`][pykka.ActorRef] in the registry.\n\n    This is done automatically when an actor is started, e.g. by calling\n    [`Actor.start()`][pykka.Actor.start].\n    \"\"\"\n    with cls._actor_refs_lock:\n        cls._actor_refs.append(actor_ref)\n    logger.debug(f\"Registered {actor_ref}\")\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.stop_all","title":"stop_all  <code>classmethod</code>","text":"<pre><code>stop_all(\n    *, block: Literal[True], timeout: float | None = ...\n) -&gt; list[bool]\n</code></pre><pre><code>stop_all(\n    *, block: Literal[False], timeout: float | None = ...\n) -&gt; list[Future[bool]]\n</code></pre><pre><code>stop_all(\n    *, block: bool = True, timeout: float | None = None\n) -&gt; list[bool] | list[Future[bool]]\n</code></pre> <pre><code>stop_all(\n    *, block: bool = True, timeout: float | None = None\n) -&gt; list[bool] | list[Future[bool]]\n</code></pre> <p>Stop all running actors.</p> <p><code>block</code> and <code>timeout</code> works as for <code>ActorRef.stop()</code>.</p> <p>If <code>block</code> is <code>True</code>, the actors are guaranteed to be stopped in the reverse of the order they were started in. This is helpful if you have simple dependencies in between your actors, where it is sufficient to shut down actors in a LIFO manner: last started, first stopped.</p> <p>If you have more complex dependencies in between your actors, you should take care to shut them down in the required order yourself, e.g. by stopping dependees from a dependency's <code>on_stop()</code> method.</p> <p>Returns:</p> <ul> <li> <code>list[bool] | list[Future[bool]]</code>           \u2013            <p>a list with the return values for each stop action</p> </li> </ul> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef stop_all(\n    cls,\n    *,\n    block: bool = True,\n    timeout: float | None = None,\n) -&gt; list[bool] | list[Future[bool]]:\n    \"\"\"Stop all running actors.\n\n    `block` and `timeout` works as for\n    [`ActorRef.stop()`][pykka.ActorRef.stop].\n\n    If `block` is `True`, the actors are guaranteed to be stopped\n    in the reverse of the order they were started in. This is helpful if\n    you have simple dependencies in between your actors, where it is\n    sufficient to shut down actors in a LIFO manner: last started, first\n    stopped.\n\n    If you have more complex dependencies in between your actors, you\n    should take care to shut them down in the required order yourself, e.g.\n    by stopping dependees from a dependency's\n    [`on_stop()`][pykka.Actor.on_stop] method.\n\n    Returns:\n        a list with the return values for each stop action\n\n    \"\"\"\n    return [\n        ref.stop(block=block, timeout=timeout) for ref in reversed(cls.get_all())\n    ]\n</code></pre>"},{"location":"reference/registry/#pykka.ActorRegistry.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(actor_ref: ActorRef[A]) -&gt; None\n</code></pre> <p>Remove an <code>ActorRef</code> from the registry.</p> <p>This is done automatically when an actor is stopped, e.g. by calling <code>Actor.stop()</code>.</p> Source code in <code>src/pykka/_registry.py</code> <pre><code>@classmethod\ndef unregister(\n    cls,\n    actor_ref: ActorRef[A],\n) -&gt; None:\n    \"\"\"Remove an [`ActorRef`][pykka.ActorRef] from the registry.\n\n    This is done automatically when an actor is stopped, e.g. by calling\n    [`Actor.stop()`][pykka.Actor.stop].\n    \"\"\"\n    removed = False\n    with cls._actor_refs_lock:\n        if actor_ref in cls._actor_refs:\n            cls._actor_refs.remove(actor_ref)\n            removed = True\n    if removed:\n        logger.debug(f\"Unregistered {actor_ref}\")\n    else:\n        logger.debug(f\"Unregistered {actor_ref} (not found in registry)\")\n</code></pre>"},{"location":"reference/runtimes/","title":"Runtimes","text":"<p>By default, Pykka builds on top of Python's regular threading concurrency model, via the standard library module <code>threading</code>.</p> <p>Pykka 2 and earlier shipped with some alternative implementations that ran on top of <code>gevent</code> or <code>eventlet</code>. These alternative implementations were removed in Pykka 3.</p> <p>Note that Pykka does no attempt at supporting a mix of concurrency runtimes.</p>"},{"location":"reference/runtimes/#threading-runtime","title":"Threading runtime","text":"<p>The default threading runtime has no dependencies other than Pykka itself and the Python standard library.</p>"},{"location":"reference/runtimes/#pykka.ThreadingFuture","title":"pykka.ThreadingFuture","text":"<p>               Bases: <code>Future[T]</code></p> <p>Implementation of <code>Future</code> for use with regular Python threads.</p> <p>Mutable messages</p> <p>The future does not make a copy of the object which is <code>set()</code> on it. It is the setters responsibility to only pass immutable objects or make a copy of the object before setting it on the future.</p> <p>Version changed: Pykka 0.14</p> <p>Previously, the encapsulated value was a copy made with <code>copy.deepcopy()</code>, unless the encapsulated value was a future, in which case the original future was encapsulated.</p> Source code in <code>src/pykka/_threading.py</code> <pre><code>class ThreadingFuture(Future[T]):\n    \"\"\"Implementation of [`Future`][pykka.Future] for use with regular Python threads.\n\n    /// warning | Mutable messages\n    The future *does not* make a copy of the object which is\n    [`set()`][pykka.Future.set] on it. It is the setters responsibility to\n    only pass immutable objects or make a copy of the object before setting\n    it on the future.\n    ///\n\n    /// note | Version changed: Pykka 0.14\n    Previously, the encapsulated value was a copy made with\n    [`copy.deepcopy()`][copy.deepcopy], unless the encapsulated value was a\n    future, in which case the original future was encapsulated.\n    ///\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._condition: threading.Condition = threading.Condition()\n        self._result: ThreadingFutureResult | None = None\n\n    def get(\n        self,\n        *,\n        timeout: float | None = None,\n    ) -&gt; Any:\n        deadline: float | None = None if timeout is None else time.monotonic() + timeout\n\n        with self._condition:\n            try:\n                return super().get(timeout=timeout)\n            except NotImplementedError:\n                pass\n\n            while self._result is None:\n                remaining = (\n                    deadline - time.monotonic() if deadline is not None else None\n                )\n                if remaining is not None and remaining &lt;= 0.0:\n                    msg = f\"{timeout} seconds\"\n                    raise Timeout(msg)\n                self._condition.wait(timeout=remaining)\n\n            if self._result.exc_info is not None:\n                (exc_type, exc_value, exc_traceback) = self._result.exc_info\n                assert exc_type is not None\n                if exc_value is None:\n                    exc_value = exc_type()\n                if exc_value.__traceback__ is not exc_traceback:\n                    raise exc_value.with_traceback(exc_traceback)\n                raise exc_value\n\n            return self._result.value\n\n    def set(\n        self,\n        value: Any | None = None,\n    ) -&gt; None:\n        with self._condition:\n            if self._result is not None or self._get_hook is not None:\n                raise queue.Full\n            self._result = ThreadingFutureResult(value=value)\n            self._condition.notify_all()\n\n    def set_exception(\n        self,\n        exc_info: OptExcInfo | None = None,\n    ) -&gt; None:\n        assert exc_info is None or len(exc_info) == 3\n        if exc_info is None:\n            exc_info = sys.exc_info()\n\n        with self._condition:\n            if self._result is not None or self._get_hook is not None:\n                raise queue.Full\n            self._result = ThreadingFutureResult(exc_info=exc_info)\n            self._condition.notify_all()\n\n    def set_get_hook(\n        self,\n        func: GetHookFunc[T],\n    ) -&gt; None:\n        with self._condition:\n            if self._result is not None:\n                raise queue.Full\n            super().set_get_hook(func)\n            self._condition.notify_all()\n</code></pre>"},{"location":"reference/runtimes/#pykka.ThreadingActor","title":"pykka.ThreadingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Implementation of <code>Actor</code> using regular Python threads.</p> Source code in <code>src/pykka/_threading.py</code> <pre><code>class ThreadingActor(Actor):\n    \"\"\"Implementation of [`Actor`][pykka.Actor] using regular Python threads.\"\"\"\n\n    use_daemon_thread: ClassVar[bool] = False\n    \"\"\"\n    A boolean value indicating whether this actor is executed on a thread that\n    is a daemon thread (`True`) or not (`False`). This must be set before\n    [`Actor.start()`][pykka.Actor.start] is called, otherwise\n    [`RuntimeError`][RuntimeError] is raised.\n\n    The entire Python program exits when no alive non-daemon threads are left.\n    This means that an actor running on a daemon thread may be interrupted at\n    any time, and there is no guarantee that cleanup will be done or that\n    [`Actor.on_stop()`][pykka.Actor.on_stop] will be called.\n\n    Actors do not inherit the daemon flag from the actor that made it. It\n    always has to be set explicitly for the actor to run on a daemonic thread.\n    \"\"\"\n\n    @staticmethod\n    def _create_actor_inbox() -&gt; ActorInbox:\n        inbox: queue.Queue[Envelope[Any]] = queue.Queue()\n        return inbox\n\n    @staticmethod\n    def _create_future() -&gt; Future[Any]:\n        return ThreadingFuture()\n\n    def _start_actor_loop(self) -&gt; None:\n        thread = threading.Thread(target=self._actor_loop)\n        thread.name = thread.name.replace(\"Thread\", self.__class__.__name__)\n        thread.daemon = self.use_daemon_thread\n        thread.start()\n</code></pre>"},{"location":"reference/runtimes/#pykka.ThreadingActor.use_daemon_thread","title":"use_daemon_thread  <code>class-attribute</code>","text":"<pre><code>use_daemon_thread: bool = False\n</code></pre> <p>A boolean value indicating whether this actor is executed on a thread that is a daemon thread (<code>True</code>) or not (<code>False</code>). This must be set before <code>Actor.start()</code> is called, otherwise <code>RuntimeError</code> is raised.</p> <p>The entire Python program exits when no alive non-daemon threads are left. This means that an actor running on a daemon thread may be interrupted at any time, and there is no guarantee that cleanup will be done or that <code>Actor.on_stop()</code> will be called.</p> <p>Actors do not inherit the daemon flag from the actor that made it. It always has to be set explicitly for the actor to run on a daemonic thread.</p>"},{"location":"reference/typing/","title":"Typing helpers","text":""},{"location":"reference/typing/#pykka.typing","title":"pykka.typing","text":"<p>Type hint helpers.</p>"},{"location":"reference/typing/#pykka.typing.ActorMemberMixin","title":"ActorMemberMixin","text":"<p>Mixin class for typing Actor methods which are accessible via proxy instances.</p> <p>Version added: Pykka 4.0</p> Source code in <code>src/pykka/typing.py</code> <pre><code>class ActorMemberMixin:\n    \"\"\"Mixin class for typing Actor methods which are accessible via proxy instances.\n\n    /// note | Version added: Pykka 4.0\n    ///\n    \"\"\"\n\n    stop = proxy_method(Actor.stop)\n    on_start = proxy_method(Actor.on_start)\n    on_stop = proxy_method(Actor.on_stop)\n    on_failure = proxy_method(Actor.on_failure)\n    on_receive = proxy_method(Actor.on_receive)\n</code></pre>"},{"location":"reference/typing/#pykka.typing.proxy_field","title":"proxy_field","text":"<pre><code>proxy_field(field: T) -&gt; Future[T]\n</code></pre> <p>Type a field on an actor proxy.</p> <p>Version added: Pykka 4.0</p> Source code in <code>src/pykka/typing.py</code> <pre><code>def proxy_field(field: T) -&gt; Future[T]:\n    \"\"\"Type a field on an actor proxy.\n\n    /// note | Version added: Pykka 4.0\n    ///\n    \"\"\"\n    return field  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/typing/#pykka.typing.proxy_method","title":"proxy_method","text":"<pre><code>proxy_method(\n    field: Callable[Concatenate[Any, P], T],\n) -&gt; Method[P, Future[T]]\n</code></pre> <p>Type a method on an actor proxy.</p> <p>Version added: Pykka 4.0</p> Source code in <code>src/pykka/typing.py</code> <pre><code>def proxy_method(\n    field: Callable[Concatenate[Any, P], T],\n) -&gt; Method[P, Future[T]]:\n    \"\"\"Type a method on an actor proxy.\n\n    /// note | Version added: Pykka 4.0\n    ///\n    \"\"\"\n    return field  # type: ignore[return-value]\n</code></pre>"}]}